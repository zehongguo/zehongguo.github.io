<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vue学习笔记</title>
    <link href="undefined2020/03/27/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>2020/03/27/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h1><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>安装</p><ol><li><p>CDN 引入</p><p><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;</code></p></li><li><p>下载和引入</p><p>开发环境 <a href="https://vuejs.org/js/vue.js" target="_blank" rel="noopener">https://vuejs.org/js/vue.js</a></p><p>生产环境 <a href="https://vue.org/js/vue.min.js" target="_blank" rel="noopener">https://vue.org/js/vue.min.js</a></p></li><li><p>npm 安装</p></li></ol><p>案例</p><ol><li><p>hellow,world</p><pre><code class="vue">&lt;div id=&quot;app&quot;&gt;    &lt;h2&gt;{{message}}&lt;/h2&gt;  &lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;const app = new Vue({  el: &quot;#app&quot;,  data: {    message: &quot;hello,vue.js&quot;  }});&lt;/script&gt;</code></pre><blockquote><p>注意：1.new Vuew({})的 V 要大写</p></blockquote></li><li><p>v-for</p><pre><code class="vue">&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;ul&gt;      &lt;li v-for=&quot;item in movies&quot;&gt;        {{item}}      &lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    const app = new Vue({      el: &#39;#app&#39;,      data: {        movies: [&#39;闻香是女人&#39;, &#39;盗梦空间&#39;, &#39; 霸王别姬&#39;]      }    })  &lt;/script&gt;&lt;/body&gt;</code></pre></li><li><p>计数器</p><pre><code class="vue">&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;h2&gt;当前数字为：{{count}}&lt;/h2&gt;    &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;    &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;  &lt;/div&gt;  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    const app = new Vue({      el: &#39;#app&#39;,      data: {        count: 0      },      methods: {        decrement() {          this.count--        },        increment() {          this.count++        }      }    })  &lt;/script&gt;&lt;/body&gt;</code></pre></li></ol><p>模板语法</p><ol><li><p>常见指令</p><ul><li><p>v-once:只渲染一次</p><pre><code class="vue">&lt;h2 v-once&gt;{{message}}&lt;/h2&gt;</code></pre></li><li><p>v-html:渲染 html 片段</p><pre><code class="vue">&lt;h2 v-html=&quot;url&quot;&gt;&lt;/h2&gt;</code></pre></li><li><p>v-text:渲染数据，但是不够灵活，只能渲染数据里面的内容</p><pre><code class="vue">&lt;h2 v-text=&quot;url&quot;&gt;&lt;/h2&gt;</code></pre></li><li><p>v-cloak:当 Vue 对象创建前存在这个属性，创建后这个属性消失，可以用来动态显示样式</p><pre><code class="html">&lt;style&gt;  [v-cloak] {    display: none;  }&lt;/style&gt;&lt;div id=&quot;app&quot;&gt;  &lt;h2 v-cloak&gt;{{message}}&lt;/h2&gt;&lt;/div&gt;</code></pre><pre><code class="js">setTimeout(function() {  var vm = new Vue({    el: &quot;#app&quot;,    data: {      message: &quot;hahah&quot;    },    methods: {}  });}, 2000);</code></pre></li><li><p>v-bind 用于绑定属性</p><pre><code class="vue">&lt;img v-bind:src=&quot;...&quot; /&gt;</code></pre><blockquote><p>语法糖写法 &lt;img:src=”…” alt=”” &gt;</p></blockquote></li><li><p>v-bind 动态绑定 class</p><p>对象语法</p><pre><code class="vue">&lt;div v-bind:class=&quot;{ key: value1, key2: value2 }&quot;&gt;&lt;/div&gt;&lt;div v-bind:class=&quot;{ 类名: boolean }&quot;&gt;&lt;/div&gt;&lt;div v-bind:class=&quot;{ active: isActive, line: isLine }&quot;&gt;  {{message}}&lt;/div&gt;</code></pre></li><li><p>v-bind 动态绑定 style</p><p>对象语法</p><pre><code class="vue">&lt;p  v-bind:style=&quot;{ color: pColor, fontSize: finalFS + &#39;px&#39; }&quot;&gt;阿拉善凯迪拉克函数&lt;/p&gt;</code></pre></li><li><p>computed 计算属性</p><pre><code class="js">computed: {        fullName: function () {          return this.firstName + &#39; &#39; + this.laseName;        }      },</code></pre><blockquote><p>computed 是计算属性，在使用的使用直接使用变量名，如</p><p>注意：computed 是有缓存的，第一次调用执行函数体，以后调用不执行函数体。</p></blockquote><p>computed setter 与 getter</p><pre><code>      computed: {        fullName: {          set: function (newValue) {            this.firstName = newValue.split(&#39; &#39;)[0];            this.lastName = newValue.split(&#39; &#39;)[1];            console.log(&quot;1111&quot;);          },          get: function () {            return this.firstName + &#39; &#39; + this.lastName          }        }      },</code></pre></li><li><p>v-on</p><blockquote><p>在事件定义是，写方法时省略了小括号，但是方法本身是需要一个参数的，这个时候 Vue 会默认将浏览器生产的 event 事件对象作为参数传入到方法</p></blockquote><pre><code class="vue">&lt;button @click=&quot;btnClick&quot;&gt;&lt;/button&gt; btnClick(event) { console.log(event) }</code></pre><blockquote><p>当既需要传递参数又需要传递事件时，可以使用$envent</p></blockquote><pre><code class="vue">&lt;button @click=&quot;btn2Click(&#39;abc&#39;, $event)&quot;&gt;&lt;/button&gt;</code></pre></li><li><p>v-on 修饰符</p><p>@click.stop 阻止冒泡</p><p>@click.prevent 阻止默认行为</p><p>@click.native -监听组件根元素的原生事件</p><p>@click.once - 只触发一次回调</p></li><li><p>v-if v-else-if v-else</p><pre><code class="vue">&lt;div id=&quot;app&quot;&gt;    &lt;div v-if=&quot;isUser&quot;&gt;      &lt;label for=&quot;account&quot;&gt;账号登录&lt;/label&gt;      &lt;input id=&quot;account&quot; type=&quot;text&quot; placeholder=&quot;账号&quot; key=&quot;account&quot;&gt;    &lt;/div&gt;    &lt;div v-else&gt;      &lt;label for=&quot;email&quot;&gt;邮箱登录&lt;/label&gt;      &lt;input id=&quot;email&quot; type=&quot;text&quot; placeholder=&quot;邮箱&quot; key=&quot;email&quot;&gt;    &lt;/div&gt;    &lt;button @click=&quot;isUser = !isUser&quot;&gt;切换登录方式&lt;/button&gt;  &lt;/div&gt;</code></pre><blockquote><p>key 的作用是区别相同元素</p></blockquote></li><li><p>v-show 与 v-if</p><blockquote><p>v-show 为 false 是，该元素增加 display:none 属性</p><p>v-if 为 false 时，不存在对应 dom 元素</p><p>所以显示与隐藏之间切换频繁用 v-show,否则用 v-if</p></blockquote></li><li><p>v-for 遍历对象</p><pre><code class="vue">&lt;ul&gt;      &lt;li v-for=&quot;(value,key) in person&quot;&gt;{{value}}{{key}}&lt;/li&gt;&lt;/ul&gt;&lt;!-- person: {          name: &quot;gzh&quot;,          age: 29,        }--&gt;</code></pre></li><li><p>Vue.set(this.letters,0,’bb’)</p><p>参数 1，要修改的数组</p><p>参数 2，索引值</p><p>参数 3，修改后的值</p><pre><code class="js">//响应式数组方法// 1. pop// 2.push// 3.shift// 4.unshift// 5.splice// 6.split// 7.sort// 8.reverse// 9.Vue.set(this.letter, 0, &#39;c&#39;)// 10.Vue.delete()//不能响应的方法// this.letter[0] = &#39;b&#39;</code></pre></li><li><p>filters</p><p>传入属性，对属性进行改造</p><pre><code class="vue">&lt;h2&gt;{{book.price | finalPrice}}&lt;/h2&gt;</code></pre><pre><code class="js">filters: {        finalPrice(price) {          return &quot;￥&quot; + price.toFixed(2);        }      }</code></pre></li><li><p>v-model</p><p>实现表单的双向绑定</p><pre><code class="vue">&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;</code></pre><pre><code>radio</code></pre><pre><code class="vue">&lt;label for=&quot;male&quot;&gt;  &lt;input type=&quot;radio&quot; id=&quot;male&quot; value=&quot;man&quot; v-model=&quot;sex&quot;&gt;男&lt;/label&gt;&lt;label for=&quot;frame&quot;&gt;  &lt;input type=&quot;radio&quot; id=&quot;frame&quot; value=&quot;woman&quot; v-model=&quot;sex&quot;&gt;女&lt;/label&gt;</code></pre><pre><code>checkbox单选情况</code></pre><pre><code class="vue">&lt;label  for=&quot;agree&quot;&gt;&lt;input type=&quot;checkbox&quot; id=&quot;agree&quot; v-model=&quot;isAgree&quot;&gt; 同意&lt;/label&gt;</code></pre><pre><code>多选情况</code></pre><pre><code class="vue">&lt;input type=&quot;checkbox&quot; id=&quot;&quot; value=&quot;篮球&quot; v-model=&quot;hobbies&quot;&gt;篮球      &lt;input type=&quot;checkbox&quot; id=&quot;&quot; value=&quot;羽毛球&quot; v-model=&quot;hobbies&quot;&gt;羽毛球      &lt;input type=&quot;checkbox&quot; id=&quot;&quot; value=&quot;足球&quot; v-model=&quot;hobbies&quot;&gt;足球      &lt;input type=&quot;checkbox&quot; id=&quot;&quot; value=&quot;乒乓球&quot; v-model=&quot;hobbies&quot;&gt;兵乓球</code></pre><pre><code class="js">isAgree: false,hobbies: []</code></pre><pre><code>select单选情况</code></pre><pre><code class="vue">&lt;select id=&quot;&quot; v-model=&quot;fruit&quot;&gt;  &lt;option value=&quot;苹果&quot;&gt;苹果&lt;/option&gt;  &lt;option value=&quot;青枣&quot;&gt;青枣&lt;/option&gt;  &lt;option value=&quot;葡萄&quot;&gt;葡萄&lt;/option&gt;  &lt;option value=&quot;榴莲&quot;&gt;榴莲&lt;/option&gt;&lt;/select&gt;</code></pre><pre><code>多选情况</code></pre><pre><code class="vue">&lt;select id=&quot;&quot; v-model=&quot;fruits&quot; multiple&gt;  &lt;option value=&quot;苹果&quot;&gt;苹果&lt;/option&gt;  &lt;option value=&quot;青枣&quot;&gt;青枣&lt;/option&gt;  &lt;option value=&quot;葡萄&quot;&gt;葡萄&lt;/option&gt;  &lt;option value=&quot;榴莲&quot;&gt;榴莲&lt;/option&gt;&lt;/select&gt;</code></pre><p>修饰符</p><pre><code>lazy当失去焦点或者按回车才会引起data的变化</code></pre><pre><code class="vue"> &lt;input type=&quot;text&quot; v-model.lazy=&quot;message&quot;&gt;</code></pre></li></ul><h4 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h4><p>父子组件通信</p><pre><code class="html">&lt;div id=&quot;app&quot;&gt;  &lt;cpn :cmovies=&quot;movies&quot; :cmessage=&quot;message&quot;&gt; &lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt;  &lt;div&gt;    &lt;ul&gt;      &lt;li v-for=&quot;item in cmovies&quot;&gt;        {{item}}      &lt;/li&gt;    &lt;/ul&gt;    &lt;h2&gt;{{cmessage}}&lt;/h2&gt;    &lt;h2&gt;{{selfProps}}&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  const cpn = {    template: &quot;#cpn&quot;,    // props: [&#39;cmovies&#39;, &#39;cmessage&#39;],    //父组件属性    props: {      cmessage: String,      cmovies: {        type: Array,        required: true,        default() {          return [&quot;不是海王&quot;, &quot;不是海贼王&quot;];        }      }    },    data() {      return {        selfProps: &quot;哈哈哈&quot; //组件属性必须写成函数形式      };    }  };  var vm = new Vue({    el: &quot;#app&quot;,    data: {      message: &quot;hello,world&quot;,      movies: [&quot;海王&quot;, &quot;海贼王&quot;]    },    methods: {},    components: {      cpn: cpn //局部注册组件    }  });&lt;/script&gt;</code></pre><p>子传父操作</p><p>子组件使用 this.$emit()发射，</p><p>父组件使用自定义事件接收</p><pre><code class="vue">&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;cpn @itemclick=&#39;itemClick&#39;&gt;&lt;/cpn&gt;  &lt;/div&gt;  &lt;template id=&quot;cpn&quot;&gt;    &lt;div&gt;      &lt;button style=&quot;margin: 10px;&quot; @click=&quot;btnClick(item)&quot; v-for=&quot;item in categories&quot; :key=&quot;item.id&quot;&gt;        {{item.name}}      &lt;/button&gt;    &lt;/div&gt;  &lt;/template&gt;  &lt;script&gt;    const cpn = {      template: &quot;#cpn&quot;,      data() {        return {          categories: [{            id: 1,            name: &quot;家电&quot;,            price: 100.00,          }, {            id: 2,            name: &quot;手机&quot;,            price: 100.00,          }, {            id: 3,            name: &quot;日用&quot;,            price: 100.00,          }]        }      },      methods: {        btnClick(item) {          this.$emit(&quot;itemclick&quot;, item);        }      }    }    var vm = new Vue({      el: &#39;#app&#39;,      data: {},      methods: {        itemClick(item) {          console.log(item.name);        }      },      components: {        cpn      }    });  &lt;/script&gt;&lt;/body&gt;</code></pre><p>props 验证具体图</p><p><img src="../../public/img/20200327/props%E9%AA%8C%E8%AF%81.png" srcset="/img/loading.gif" alt></p><p>父组件访问子组件使用$children、 $refs</p><pre><code class="vue">&lt;div id=&quot;app&quot;&gt;  &lt;cpn ref=&quot;children&quot;&gt;&lt;/cpn&gt;    &lt;button @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt;</code></pre><pre><code class="js">btnClick() {    console.log(this.$refs.children.price);}</code></pre><p>子组件访问父组件使用$parent</p><h3 id="slot-插槽"><a href="#slot-插槽" class="headerlink" title="slot 插槽"></a>slot 插槽</h3><blockquote><p>使用插槽可以定义组件里不同的内容</p></blockquote><p>父组件</p><pre><code class="vue">&lt;div id=&quot;app&quot;&gt;  &lt;cpn&gt;    👌  &lt;/cpn&gt;  &lt;cpn&gt;    🈶  &lt;/cpn&gt;  &lt;cpn&gt;    😈  &lt;/cpn&gt;&lt;/div&gt;</code></pre><p>子组件</p><pre><code class="vue">&lt;template id=&quot;cpn&quot;&gt;  &lt;div&gt;    &lt;h2&gt;你好啊,&lt;/h2&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>具名插槽</p><blockquote><p>在插槽加上名字，可替换具体哪一个插槽</p></blockquote><pre><code class="vue">&lt;cpn1&gt;    &lt;span slot=&quot;left&quot;&gt;标题&lt;/span&gt;    &lt;button slot=&quot;center&quot;&gt;按钮&lt;/button&gt;&lt;/cpn1&gt;</code></pre><pre><code class="vue">&lt;template id=&quot;cpn2&quot;&gt;  &lt;div&gt;    &lt;slot name=&quot;left&quot;&gt;&lt;span&gt;左边&lt;/span&gt;&lt;/slot&gt;    &lt;slot name=&quot;center&quot;&gt;&lt;span&gt;中间&lt;/span&gt;&lt;/slot&gt;    &lt;slot&gt;&lt;span&gt;右边&lt;/span&gt;&lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>作用域插槽</p><p>父组件获取子组件的数据</p><pre><code class="vue">&lt;cpn&gt;  &lt;div slot-scope=&quot;slot&quot;&gt;    &lt;span v-for=&quot;item in slot.data&quot;&gt;    {{item}}    &lt;/span&gt;  &lt;/div&gt;&lt;/cpn&gt;</code></pre><pre><code class="vue">&lt;template id=&quot;cpn&quot;&gt;  &lt;div&gt;    &lt;!-- &lt;h2&gt;你好啊,&lt;/h2&gt;  &lt;slot&gt;&lt;/slot&gt; --&gt;    &lt;slot :data=&quot;pLanuage&quot;&gt;      &lt;ul&gt;        &lt;li v-for=&quot;item in pLanuage&quot;&gt;{{ item }}&lt;/li&gt;      &lt;/ul&gt;    &lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>脚手架安装</p><p><code>npm @vue/cli -g</code></p><p>vue 解析顺序</p><pre><code>template-&gt;ast-&gt;render-&gt;vdom-&gt;ui</code></pre><p>初始化一个 vue 项目</p><p>``</p><h4 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h4><p>html 中的 history 模式</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History/back" target="_blank" rel="noopener"><code>History.back()</code></a></p><p>前往上一页, 用户可点击浏览器左上角的返回按钮模拟此方法. 等价于</p><pre><code>history.go(-1)</code></pre><p><strong>Note:</strong> 当浏览器会话历史记录处于第一页时调用此方法没有效果，而且也不会报错</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History/forward" target="_blank" rel="noopener"><code>History.forward()</code></a></p><p>在浏览器历史记录里前往下一页，用户可点击浏览器左上角的前进按钮模拟此方法. 等价于</p><pre><code>history.go(1)</code></pre><p><strong>Note:</strong> 当浏览器历史栈处于最顶端时( 当前页面处于最后一页时 )调用此方法没有效果也不报错。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History/go" target="_blank" rel="noopener"><code>History.go()</code></a></p><p>通过当前页面的相对位置从浏览器历史记录( 会话记录 )加载页面。比如：参数为-1 的时候为上一页，参数为 1 的时候为下一页. 当整数参数超出界限时( 译者注:原文为 When <code>*integerDelta*</code> is out of bounds )，例如: 如果当前页为第一页，前面已经没有页面了，我传参的值为-1，那么这个方法没有任何效果也不会报错。调用没有参数的 <code>go()</code>方法或者不是整数的参数时也没有效果。( 这点与支持字符串作为 url 参数的 IE 有点不同)。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History/pushState" target="_blank" rel="noopener"><code>History.pushState()</code></a></p><p>按指定的名称和 URL（如果提供该参数）将数据 push 进会话历史栈，数据被 DOM 进行不透明处理；你可以指定任何可以被序列化的 javascript 对象。</p><p><strong>Note:</strong> 在 Gecko 2.0 (Firefox 4 / Thunderbird 3.3 / SeaMonkey 2.1) 到 Gecko 5.0 (Firefox 5.0 / Thunderbird 5.0 / SeaMonkey 2.2)中， 被传递的对象使用 JSON 进行序列化. 从 Gecko 6.0 (Firefox 6.0 / Thunderbird 6.0 / SeaMonkey 2.3)开始，使用<a href="https://developer.mozilla.org/en/DOM/The_structured_clone_algorithm" target="_blank" rel="noopener">结构化克隆算法</a>进行序列化。这样，就可以让更多类型的对象被安全地传输。</p><p><code>History.replaceState()</code></p><p>按指定的数据，名称和 URL(如果提供该参数)，更新历史栈上最新的入口。这个数据被 DOM 进行了不透明处理。你可以指定任何可以被序列化的 javascript 对象。注意到 Firefox 现在忽略了这个 title 参数，更多的信息，请看<a href="https://developer.mozilla.org/en/DOM/Manipulating_the_browser_history" target="_blank" rel="noopener">manipulating the browser history</a>。</p><blockquote><p>更新历史栈，但无法返回</p></blockquote><p>安装</p><pre><code class="shell">npm install vue-router -s -d</code></pre><p>使用</p><ol><li><p>新建 router 文件夹并新建 index.js 文件</p></li><li><p>在文件中编写代码</p><pre><code class="js">import Vue from &quot;vue&quot;;import VueRouter from &quot;vue-router&quot;;import Home from &quot;../components/Home.vue&quot;;import About from &quot;../components/About.vue&quot;;// 1.注册VueRouter插件Vue.use(VueRouter);// 路由路径数组const routes = [  {    path: &quot;/home&quot;, //路径    component: Home  },  {    path: &quot;/about&quot;,    component: About  }];// 2.创建VueRouterconst router = new VueRouter({  routes});// 3.导出router对象export default router;</code></pre></li><li><p>在 main.js 中注册</p><pre><code class="js">import router from &quot;./router&quot;;new Vue({  render: h =&gt; h(App),  router}).$mount(&quot;#app&quot;);</code></pre></li><li><p>在 app.vue 中使用</p><pre><code class="vue">&lt;div id=&quot;app&quot;&gt;    &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt;    &lt;router-link to=&quot;/about&quot;&gt;关于&lt;/router-link&gt;    &lt;router-view /&gt;  &lt;/div&gt;</code></pre><blockquote><p>router-link 跳转至组件的超链接</p><p>router-view 占位符，点击哪个路由就显示哪个组件</p></blockquote></li><li><p>注意点</p><p>如果修改成 history 模式</p><pre><code class="js">const router = new VueRouter({  routes,  mode: &quot;history&quot;});</code></pre><p> 默认值,重定向</p><p> 在router数组首位中添加</p><pre><code class="js"> {   path: &#39;&#39;,   redirect: &quot;/home&quot; }</code></pre><p> <code>&lt;router-link&gt;&lt;/router-link&gt;</code>属性</p><ul><li><p>tag属性，可以指定这个标签为哪个dom元素</p><pre><code class="vue">&lt;router-link tag=&quot;button&quot;&gt;&lt;/router-link&gt;</code></pre></li><li><p>replace属性，可以更新url并清除history。</p></li><li><p>改变router-link当前选中的class</p><pre><code class="js">const router = new VueRouter({  routes,  mode: &#39;history&#39;,  linkActiveClass: &quot;active&quot;});</code></pre></li></ul></li></ol></li></ol><pre><code> 6. 通过代码修改路径    `this.$router.push(&#39;/home&#39;)`    `this.$router.replace(&quot;/about&quot;)` 7. 动态绑定路由    1. 在配置路由映射数组中修改路由地址       ```js        {         path: &quot;/user/:id&quot;,         component: User       }       ```    2. 修改link-router       ```vue       &lt;router-link :to=&quot;&#39;/user/&#39;+userid&quot; tag=&quot;span&quot;&gt;我是用户相关&lt;/router-link&gt;       ```    3. 在跳转页面获取该参数       ```js       $route.params.id       ``` 8. 路由懒加载    ```js    const Home = () =&gt; import (../components/Home);    ``` 9. 嵌套路由    子路由    ```js    {      path: &quot;/home&quot;,      component: Home,      children: [{        path: &#39;&#39;,        redirect: &#39;news&#39;,      }, {        path: &#39;news&#39;,        component: HomeNews      }, {        path: &#39;message&#39;,        component: HomeMessage      }]    ```    在父组件中    ```vue        &lt;router-link to=&quot;/home/news&quot;&gt;新闻列表&lt;/router-link&gt;        &lt;router-link to=&quot;/home/message&quot;&gt;消息列表&lt;/router-link&gt;        &lt;router-view&gt;&lt;/router-view&gt;    ``` 10. 传递query参数    传递    ```vue    &lt;router-link          :to=&quot;{path:&#39;/home/news&#39;,query:{name:&#39;gzh&#39;,age:&#39;18&#39;,sex:&#39;man&#39;,habbits:[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;]}}&quot;        &gt;新闻列表&lt;/router-link&gt;    ```    获取    ```vue    &lt;ul&gt;          &lt;li v-for=&quot;item in $route.query.habbits&quot; :key=&quot;item&quot;&gt;{{item}}&lt;/li&gt;        &lt;/ul&gt;    {{$route.query.name}}    {{$route.query.age}}    {{$route.query.sex}}    ``` 11. 通过代码传递     ```js     this.$route.push({         path:&quot;/home/message&quot;,         query:{             name:&#39;GZH&#39;,             age:18,             sex:&#39;female&#39;         }     })     ``` 12. 全局导航守卫     &gt; 作用：在路由跳转前的一个回调函数，写在router-&gt;index.js中     `router.beforeEach()`     示例：修改浏览器导航栏标题     ```js     {       path: &quot;/about&quot;,       component: About,       meta: {         title: &quot;关于&quot;       }     }     ```     ```js     router.beforeEach((to, from, next) =&gt; {       document.title = to.matched[0].meta.title;       console.log(to);       next();     });     ```     `router.afterEach()`后置钩子 13. keep-alive      作用：切换组件时不被销毁,相当于缓存组件     ```vue     &lt;keep-alive exclude=&quot;User&quot;&gt;         &lt;router-view /&gt;     &lt;/keep-alive&gt;     ```     &gt; exduce属性为将User组件排除，即User组件不缓存      有了keep-alive后，有两个钩子函数     `activated()` 显示当前组件      `deactivated()` 不显示当前组件     ### Toolbar案例     需要注意的点     #### css部分     + 全局 样式       在assets文件夹新建css文件夹，创建全局css文件base.css       然后再App.Vue文件的`&lt;style&gt;&lt;/style&gt;`中使用`@improt(&#39;./assets/css/base.css&#39;);`     + toolbar高度一般使用`49px`     + 固定地府使用`position:fixed;`固定      #### 路径问题     给路径起别名，在vue配置文件中alias中     ![](../../public/img/20200327/path.png)     在使用的时候直接使用assets,代替src/assets。     &gt; 如果是在tempalet中则使用~assets ### Vuex &gt;  类似于redux 安装 `npm install vuex -s` ![](../../public/img/20200327/vuex.png)  使用步骤 1. 安装 2. 新建store.js 3. 编写以下代码    ```js    import Vue from &#39;vue&#39;;    import Vuex from &#39;vuex&#39;;    Vue.use(Vuex);    const moduleA = {      state: {        name: &#39;郭泽鸿&#39;      },      getters: {        fullName(state) {          return state.name + &#39;-同学&#39;;        }      },      mutations: {        changeName(state) {          state.name = &#39;gzh&#39;;        }      },      actions: {      },    };    export default new Vuex.Store({      state: {        count: 1      },      getters: {        //正常        getCountFomat(state) {          return state.count + &#39;次&#39;;        },        //调用getters中的方法        getCountFomat1(state, getters) {          return getters.getCountFomat + &#39;啊&#39;;        },        //如果使用的时候有参数        getCountFomat2(state, getters) {          return function (msg) {            return getters.getCountFomat1 + msg;          };        }      },      mutations: {        increamCount(state) {          state.count++;        },        decreamCount(state, payload) {          state.count -= payload.count;        },        toZero(state) {          state.count = 0;        }      },      actions: {        //context为上下文        toZeroAsync(context, playload) {          return new Promise((resolve) =&gt; {            setTimeout(() =&gt; {              context.commit(&#39;toZero&#39;);              console.log(&quot;我在里面执行&quot; + playload);              resolve(&#39;我是执行完的结果&#39;);            }, 1000);          });        }      },      modules: {        a: moduleA      }    });    ```    state为数据源，    getters类似于computed属性，    mutations一般写改变states值得方法，store状态更新的唯一方式    actions发送网络请求    moudles模块化操作，注意在调用模块的属性时，只有调用state里面的属性需要加上模块名，其他不需要    ```vue    {{$stroe.state.a.name}}    {{$stroe.getters.getCountFomat()}}//会自动在根对象查找，查找不到在模块中查找    ``` 4. 在main.js引用    ```js    new Vue({      render: h =&gt; h(App),      router,      store    }).$mount(&#39;#app&#39;);    ``` 5. 在组件中使用    ```vue    &lt;template&gt;      &lt;div&gt;        &lt;h2&gt;当前计数:{{$store.state.count}}&lt;/h2&gt;        &lt;h2&gt;格式化数据:{{$store.getters.getCountFomat}}&lt;/h2&gt;        &lt;h2&gt;格式化数据1:{{$store.getters.getCountFomat1}}&lt;/h2&gt;        &lt;h2&gt;格式化数据2:{{$store.getters.getCountFomat2('我是参数')}}&lt;/h2&gt;        &lt;button @click=&quot;add&quot;&gt;-&lt;/button&gt;        &lt;button @click=&quot;sub(5)&quot;&gt;+&lt;/button&gt;        &lt;br /&gt;        &lt;button @click=&quot;clearZero&quot;&gt;归0&lt;/button&gt;        &lt;br /&gt;        &lt;h2&gt;------modules------&lt;/h2&gt;        &lt;span&gt;我的名字是:{{$store.state.a.name}}&lt;/span&gt;        &lt;br /&gt;        &lt;span&gt;我的名字是:{{$store.getters.fullName}}&lt;/span&gt;        &lt;br /&gt;        &lt;button @click=&quot;changeClick&quot;&gt;更新&lt;/button&gt;      &lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;    export default {      name: &quot;Counter&quot;,      methods: {        add() {          this.$store.commit(&quot;increamCount&quot;);        },        sub(num) {          // mutations第二种提交方式          this.$store.commit({            type: &quot;decreamCount&quot;,            count: num       });        },     clearZero() {          // this.$store.commit(&quot;toZero&quot;);          this.$store.dispatch(&quot;toZeroAsync&quot;, &quot;我是playload参数&quot;).then(result =&gt; {            console.log(result);          });        },        changeClick() {          this.$store.commit(&quot;changeName&quot;);        }      }    };    &lt;/script&gt;    &lt;style&gt;    &lt;/style&gt;    ```    mapGetters,mapActions等等    + mapGetters用于简写store中的getter方法      ```js      // 用法      // 1.在需要用到的组件中引入      import { mapGetters } from &quot;vuex&quot;;      // 2.在computed中添加      ...mapGetters([&quot;totalPrice&quot;, &quot;totalCount&quot;])      // 3.使用,不用this.$store.getters.totalPrice      this.totalPrice      ```    + mapActions类似    ### 网络封装模块使用axios    发送请求    ```js    $axios({        url:&#39;&#39;,        type:&#39;post&#39;,        params:{            id:1        }    })    .then((res)=&gt;{        console.log(res.data);    })    ```    发送并发请求    ```js    axios.all([axios.get(&quot;url1&quot;),                        axios.get(&#39;url2&#39;,                        params:{{id:1}})                        ])                        .then(axios.spread((res1,res2)=&gt;{                                console.log(res1);                                console.log(res2);                            }));    ```    封装axios    ```js    import axios from &#39;axios&#39;;    export function request(config) {      const instance1 = axios.create({        baseURL: &quot;http://123.207.32.32:8000/&quot;,        timeout: 5000      });      return instance1(config);    }    ```    ```js    import {request} from &#39;../server/request&#39;    request({          url: &quot;/home/multidata&quot;        })          .then(res =&gt; {            console.log(res.data);          })          .catch(err =&gt; {            console.log(err);          });    ```    拦截器    1. 请求拦截器       ```js       instance.interceptors.request.use(config =&gt; {           // 进行相关操作         // 比如过滤headers，         // 携带token         config.data = Object.assgin({},config.data,Token);           return config;       }, err =&gt;{           //进行相关操作       })       ```    2. 响应拦截器       ```js       instance.interceptors.response.use(res =&gt; {           return res.data;       },err =&gt; {         console.log(err);       });       ```</code></pre><h2 id="商城项目"><a href="#商城项目" class="headerlink" title="商城项目"></a>商城项目</h2><h3 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h3><ol><li>划分目录结构</li></ol><p><img src="../../public/img/20200327/catalog.png" srcset="/img/loading.gif" alt></p><ol start="2"><li><p>在 App.vue 导入 base.css 和 normalize.css 文件初始化样式</p></li><li><p>配置 vue.config.js，设置路径别名</p><pre><code class="js">module.exports = {  configureWebpack: {    resolve: {      alias: {        assets: &quot;@/assets&quot;,        components: &quot;@/components&quot;,        pages: &quot;@/pages&quot;,        server: &quot;@/server&quot;,        common: &quot;@/common&quot;      }    }  }};</code></pre></li></ol><p>4) 将项目进行模块划分:tabbar-&gt;路由映射关系</p><h3 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h3><ol><li><p>导航栏开发</p></li><li><p>轮播图开发</p><blockquote><p>注意，在 A 组件中引用 B 组件，A 组件的 name 不能和导入 B 组件的名字一样，否则会导致内存泄露；</p></blockquote><p><img src="../../public/img/20200327/navbartips.png" srcset="/img/loading.gif" alt></p></li><li><p>推荐组件</p></li><li><p>货物列表</p><p>使用 better-scroll 使滚动更加顺滑</p><p><code>npm install better-scroll</code></p><p><img src="../../public/img/20200327/betterscroll.png" srcset="/img/loading.gif" alt></p><blockquote><p>在 vue 中不能在 ceated 中初始化 better-scroll，应在 mounted 中</p></blockquote><pre><code class="js">//监听滚动this.bscroll.on(&quot;scroll&quot;, position =&gt; {  this.$emit(&quot;scroll&quot;, position);});//监听上拉更新,当数据异步加载完成需要调用refresh刷新scrollthis.bscroll.on(&quot;pullingUp&quot;, () =&gt; {  this.$emit(&quot;pullingUp&quot;);});</code></pre><p>更多详细用法请查看 better-scroll 官网。</p></li><li><p>事件总线，派发监听事件和响应事件</p><ul><li><p>在 vue 原型 prototype 中添加<code>Vue.prototype.$bus = new Vue();</code></p></li><li><p>被监听者</p><pre><code class="js">this.$bus.$emit(&quot;imageLoadFinish&quot;);</code></pre></li><li><p>监听者</p><pre><code class="js">this.$bus.$on(&quot;imageLoadFinish&quot;, () =&gt; {  //...});</code></pre></li><li><p>取消</p><pre><code class="js">this.$bus.$off(&quot;全局事件&quot;, &quot;当前函数&quot;);</code></pre></li></ul></li></ol><p>6) 防抖函数</p><p>   防止 refresh 多次调用。</p><pre><code class="js">   debounce(func, delay) {     let timer = null;         return function(...args) {         //判断是否有定时器，如果有清除掉定时器.             timer &amp;&amp; clearTimeout(timer);             timer = setTimeout(() =&gt; {             func.apply(this, args);         }, delay);     };   }</code></pre><p>7) 吸顶效果</p><ul><li><p>获取组件的 offsetTop</p><p><code>this.$ref.tabControl.$el.offsetTop</code></p></li></ul><p>8) mixin 混入，将不同组件相同逻辑的代码放到一个 mixin 的方法里。</p><p>9) this.$nextTick(()=&gt;()),当数据和 dom 全部渲染完会调用。</p><blockquote><p>用在标题滚动到内容</p></blockquote><p>10) 安装自定义插件</p><p>11) 在 main.js 注册<code>Vue.use(toast);</code></p><p>12) 新建一个 js 文件</p><pre><code>```jsimport Toast from &quot;./Toast.vue&quot;;const toastObj = {};toastObj.install = function(Vue) {  // 1. 创建组件构造器  const toastConstructor = Vue.extend(Toast);  // 2. 使用new 创建一个组件对象  const toastComp = new toastConstructor();  // 3. 将组件对象挂载到dom元素上  toastComp.$mount(document.createElement(&quot;div&quot;));  // 4. toast.$el对应的div  document.body.appendChild(toastComp.$el);  // 5. 将对象挂载到Vue prototype上  Vue.prototype.$toast = toastComp;};export default toastObj;```</code></pre><p>13) 使用<code>this.$toast.show(&quot;您未选中商品&quot;);</code></p><p>14) fastClick 解决 300ms 延迟</p><pre><code>`npm install fastclick`在 main.js 照片那个使用 fastclick.attach(document.body)</code></pre><p>15) 使用 vue-lazyload 实现图片懒加载</p><pre><code>`npm install vue-lazyload`在 main.js 使用```jsVue.use(VueLazyLoad,{    loading:require(&quot;占位符图片&quot;);});```将`:src`改为`v-lazy`</code></pre><p>16) 移动端适配<code>postcss-px-to-viewport</code>插件改变 css 单位 px 为 vm</p><pre><code>`npm install postcss-px-to-view --save-dev`创建 postcss.config.js</code></pre><p><img src="../images/px2vw.png" srcset="/img/loading.gif" alt="image-20200321143746470"></p><h4 id="vue-面试题"><a href="#vue-面试题" class="headerlink" title="vue 面试题"></a>vue 面试题</h4><ul><li><p>vue 的响应式原理</p><p><img src="../images/vueprototype.png" srcset="/img/loading.gif" alt></p><p><img src="../images/vuethory.png" srcset="/img/loading.gif" alt></p></li><li><p>采用<code>Object.defineProperty(object,key,{get(){},set(newValue){}})</code>来监测属性值的改变</p></li><li><p>采用订阅发布者模式来通知视图的更新</p><pre><code class="js">// 发布者class Dep {  constructor() {    this.subs = [];  }  addSubs(watcher) {    this.subs.push(watcher);  }  notify() {    this.subs.forEach(item =&gt; {      item.update();    });  }  remove(watcher) {    this.subs = this.subs.fitler(item =&gt; item === watcher);  }}// 订阅者class Watcher {  constructor(name) {    this.name = name;  }  update() {    console.log(this.name + &quot;发生改变,可以更新视图了&quot;);  }}// 模拟data对象const obj = {  name: &quot;郭泽鸿&quot;,  age: 18};Object.keys(obj).forEach(key =&gt; {  let value = obj[key];  //一个属性新增一个dep对象  let dep = new Dep();  Object.defineProperty(obj, key, {    set(newValue) {      if (value === newValue) return;      value = newValue;      dep.notify();    },    get() {      const watcher = new Watcher(value);      dep.addSubs(watcher);      return value;    }  });});</code></pre></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>js高级复习2</title>
    <link href="undefined2019/10/24/js%E9%AB%98%E7%BA%A72/"/>
    <url>2019/10/24/js%E9%AB%98%E7%BA%A72/</url>
    
    <content type="html"><![CDATA[<h1 id="js高级复习2"><a href="#js高级复习2" class="headerlink" title="js高级复习2"></a>js高级复习2</h1><h2 id="4-继承"><a href="#4-继承" class="headerlink" title="4. 继承"></a>4. 继承</h2><h3 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h3><pre><code class="js">    //父类 人类 --- 姓名，年龄，性别， -行为- 吃，玩    //子类 学生 --- 姓名，年龄，性别， -行为- 吃，玩，学习    function Person(name, age, sex) {      this.name = name;      this.age = age;      this.sex = sex || 1;    }    Person.prototype.eat = function () {      console.log(this.name + &quot;吃东西&quot;);    }    Person.prototype.play = function () {      console.log(this.name + &quot;玩&quot;)    }    function Student(sorce) {      this.sorce = sorce;    }    Student.prototype = new Person(&quot;小明&quot;, 18, 1);    Student.prototype.study = function () {      console.log(this.name + &quot;在学习&quot;);    }    let stu = new Student(&quot;100&quot;);    console.dir(stu);    stu.study();</code></pre><blockquote><p>优点：优点是继承了父类的模板，又继承了父类的原型对象</p><p> 缺点：对象属性固定，修改起来麻烦；例如连续创建几个学生实例对象，名字都是相同，要改则需要用stu.name = “…”，这样修改。</p></blockquote><h3 id="2-借用构造函数修改"><a href="#2-借用构造函数修改" class="headerlink" title="2. 借用构造函数修改"></a>2. 借用构造函数修改</h3><pre><code class="js">function Person(name, age, sex) {  this.name = name;  this.age = age;  this.sex = sex;}Person.prototype.eat = function () {  console.log(&quot;吃饭饭&quot;);};function Student(name, age, sex, score) {  Person.call(this, name, age, sex);//利用call的方法执行Person构造函数，初始化属性  this.score = score;}let stu = new Student(&quot;小明&quot;, 18, &quot;男&quot;, 100);stu.eat();</code></pre><blockquote><p>优点：比原型链继承更加灵活，实例对象时即可初始化自身属性</p><p>缺点：无法访问父类的prototype方法</p></blockquote><h3 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h3><pre><code class="js">// 借用组合继承（原型继承+借用构造函数继承）function Person(name, age, sex) {  this.name = name;  this.age = age;  this.sex = sex;}Person.prototype.eat = function () {  console.log(&quot;吃饭饭&quot;);};function Student(name, age, sex, score) {  Person.call(this, name, age, sex);  this.score = score;}Student.prototype = new Person();//改变原型指向Student.prototype.constructor = Student;//将构造函数指向本身let stu = new Student(&quot;小明&quot;, 18, &quot;男&quot;, 100);stu.eat();</code></pre><blockquote><p>优点：结合原型链继承和借用构造函数继承，就完美地解决了之前这二者各自表现出来的缺点。即可继承属性，又可继承方法</p><p>缺点：Person()方法执行了两次，一次 Person.call(this, name, age, sex);一次new Person();</p></blockquote><h3 id="4-拷贝继承"><a href="#4-拷贝继承" class="headerlink" title="4.拷贝继承"></a>4.拷贝继承</h3><pre><code class="js">//1.赋值，无开辟新空间let obj = {  name:&quot;Gzh&quot;,  age:18}let obj1 = obj;//2.开辟了新空间function Person() {}Person.prototype.name = &quot;阿萨德&quot;;Person.prototype.age = 18;Person.prototype.sex = &quot;男&quot;;Person.prototype.sayHi = function () {  console.log(&quot;hello&quot;);};let student = {};for (let key in Person.prototype) {  student[key] = Person.prototype[key];}</code></pre><blockquote><p>优点：支持多继承</p><p>缺点：1、效率较低，内存占用高（因为要拷贝父类的属性）</p><p>​            2、无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</p></blockquote><h3 id="5-寄生组合继承"><a href="#5-寄生组合继承" class="headerlink" title="5. 寄生组合继承"></a>5. 寄生组合继承</h3><pre><code class="js">    function Person(name, age, sex) {      this.name = name;      this.age = age;      this.sex = sex;    }    Person.prototype.eat = function () {      console.log(this.name + &quot;在吃饭&quot;);    }    function Student(name, age, sex, grade) {      Person.call(this, name, age, sex);      this.grade = grade;    }    (function () {      function Super() {};      Super.prototype = Person.prototype;      console.log(Super);      Student.prototype = new Super();    })();    let stu = new Student(&quot;wassupbro&quot;, 18, &quot;男&quot;, &quot;大二&quot;);    stu.eat();//wassupbro在吃饭    console.dir(stu);</code></pre><blockquote><p>优点：既可以继承属性，又可以继承方法，也只执行了一次Person的构造函数，堪称完美</p><p>缺点：实现起来稍复杂</p></blockquote><h2 id="5-call、apply、bind方法"><a href="#5-call、apply、bind方法" class="headerlink" title="5.call、apply、bind方法"></a>5.call、apply、bind方法</h2><h3 id="1-js中this指向问题"><a href="#1-js中this指向问题" class="headerlink" title="1. js中this指向问题"></a>1. js中this指向问题</h3><h4 id="1-在全局环境中"><a href="#1-在全局环境中" class="headerlink" title="1. 在全局环境中"></a>1. 在全局环境中</h4><p>在全局执行环境中（在任何函数体外部），this都是指向全局对象。在浏览器中，window对象即是全局对象;</p><pre><code class="js">console.log(this); //Windowvar a = 1;console.log(window.a);  //1</code></pre><h4 id="2-在函数环境中"><a href="#2-在函数环境中" class="headerlink" title="2.在函数环境中"></a>2.在函数环境中</h4><p> 在函数内容，this指向取决于函数调用的方式;</p><pre><code class="js">function f(){&quot;use strict&quot;; //使用严格模式console.log(this); } f(); // window ；使用严格模式时，输出undefined</code></pre><h4 id="3-作为对象的方法调用时"><a href="#3-作为对象的方法调用时" class="headerlink" title="3. 作为对象的方法调用时"></a>3. 作为对象的方法调用时</h4><p>当函数作为对象的方法被调用时，this指向调用的该函数的对象;</p><pre><code class="js">var obj = {  a: 37,  fn: function() {    return this.a;  }};console.log(obj.fn());  // 37</code></pre><h4 id="4-作为构造函数"><a href="#4-作为构造函数" class="headerlink" title="4.作为构造函数"></a>4.作为构造函数</h4><p>当一个函数用作构造函数时（使用new关键字），它的<code>this</code>被绑定到正在构造的新对象。</p><p><strong>虽然构造器返回的默认值是this所指的那个对象，但它仍可以手动返回其他的对象（如果返回值不是一个对象，则返回this对象）。</strong></p><pre><code class="js">function C(){  this.a = 37;}var o = new C();console.log(o.a); //  37function C2(){  this.a = 37;  return {a:38};}o = new C2();console.log(o.a); //  38，手动设置了返回对象</code></pre><h4 id="5-作为DOM事件处理函数"><a href="#5-作为DOM事件处理函数" class="headerlink" title="5.作为DOM事件处理函数"></a>5.作为DOM事件处理函数</h4><p>当函数被用作事件处理函数时，它的<code>this</code>指向触发事件的元素（一些浏览器在使用非<code>addEventListener</code>的函数动态添加监听函数时不遵守这个约定）。</p><h3 id="2-call和apply方法"><a href="#2-call和apply方法" class="headerlink" title="2. call和apply方法"></a>2. call和apply方法</h3><ul><li>作用：用来改变函数中this的指向</li><li>用法：Person.call(对象，参数1，参数2,…);Person.apply(对象，[参数1，参数2,…])</li><li>使用：需要调用其他对象的方法，并且this指向自身时；</li><li>实例,下面的例子↓</li></ul><pre><code class="js">function Person(name, age) {  this.name = name;  this.age = age;}Person.prototype.eat = function () {  console.log(this.name + &quot;在吃饭&quot;);};let obj = {  name: &quot;gzh&quot;,  age: 18};let per = new Person(&quot;htat&quot;, 18);per.eat(); //htat在吃饭per.eat.call(obj); //gzh在吃饭，改变了this的指向</code></pre><h3 id="3-bind方法"><a href="#3-bind方法" class="headerlink" title="3.bind方法"></a>3.bind方法</h3><ul><li><p>作用：改变this指向，复制一份到变量</p></li><li><p>实例</p><pre><code class="js">let obj = {  name: &quot;gzh&quot;,  age: 18,  eat: function () {    console.log(this.name);  }};let obj2 = {  name: &quot;http&quot;};obj2.eat = obj.eat.bind(obj2); //改变了this的指向并将eat方法复制给obj2.eatobj2.eat();//http</code></pre></li></ul><h3 id="6-闭包"><a href="#6-闭包" class="headerlink" title="6.闭包"></a>6.闭包</h3><ul><li><p>概念：函数A内的数据可以被函数B访问</p></li><li><p>模式：函数闭包，对象模式的闭包</p></li><li><p>作用：缓存数据，延长作用域；私有化变量</p></li><li><p>缺点：可能会造成数据泄露</p></li></ul><pre><code class="js">//例子：//函数模式闭包function f3() {  let num = 10;  return function () {    return ++num;  };}let f4 = f3();console.log(f4());//11 num没有被系统回收console.log(f4());//12console.log(f4());//13//对象模式闭包function f2() {  let num = 20;  let obj = {    age: num,  };  return obj;}console.log(f2().age);//函数外可以访问到f2中的变量，</code></pre><p>利用闭包实现一个点赞的案例</p><pre><code class="js">    &lt;input type=&quot;button&quot; value=&quot;点赞(1)&quot;&gt;  &lt;input type=&quot;button&quot; value=&quot;点赞(1)&quot;&gt;  &lt;input type=&quot;button&quot; value=&quot;点赞(1)&quot;&gt;  &lt;input type=&quot;button&quot; value=&quot;点赞(1)&quot;&gt;  &lt;script&gt;    let btnArr = document.getElementsByTagName(&quot;input&quot;);    for (let i = 0; i &lt; btnArr.length; i++) {      let value = 1;      btnArr[i].onclick = function () {        this.value = &quot;点赞(&quot; + (++value) + &quot;)&quot;;//注册点击事件，可以访问到value      }    }  &lt;/script&gt;</code></pre><h3 id="7-沙箱"><a href="#7-沙箱" class="headerlink" title="7. 沙箱"></a>7. 沙箱</h3><p>概念：<em>沙箱 就是形成一个密闭的环境 不能 主动的影响外界</em>，在js中就是自执行函数</p><p>作用：新建一块可用于模块运行的环境(沙箱)，自己的代码放在回调函数里，且不会对其他的个人沙箱造成影响</p><pre><code class="js">let num = 1000;((function(){  //在自执行函数中有自己的作用域  let num = 10;  console.log(num);//10})())console.log(num);//1000</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>js高级复习1</title>
    <link href="undefined2019/10/11/js%E9%AB%98%E7%BA%A7%E5%A4%8D%E4%B9%A0/"/>
    <url>2019/10/11/js%E9%AB%98%E7%BA%A7%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Javascript高级复习"><a href="#Javascript高级复习" class="headerlink" title="Javascript高级复习"></a>Javascript高级复习</h1><h2 id="1-new创建对象的本质"><a href="#1-new创建对象的本质" class="headerlink" title="1. new创建对象的本质"></a>1. new创建对象的本质</h2><pre><code class="JS">    function Person(name,age){      this.name = name;      this.age = age;      this.sayHi = function(){        return &quot;Hello,I&#39;m&quot; + this.name;      }    }    let John = new Person(name,age);    /**     * new的过程经过了这几步     * 1. let obj = {};新建一个对象，开辟空间     * 2. obj.__proto__ = Person.prototype;将对象的__proto__指向构造函数的prototype     * 3. Person.call(obj); 执行构造函数中的代码，注意。此时的this为obj     * 4. 最后返回obj     *     */</code></pre><h2 id="2-几种常见的对象创建方式"><a href="#2-几种常见的对象创建方式" class="headerlink" title="2. 几种常见的对象创建方式"></a>2. 几种常见的对象创建方式</h2><h3 id="1-字面量创建方式"><a href="#1-字面量创建方式" class="headerlink" title="1. 字面量创建方式"></a>1. 字面量创建方式</h3><pre><code class="js">    let person = {      name: &quot;孙悟空&quot;,      age: 100,      sex: 1,      power: 10000,      skill: [{          name: &quot;龟派气功&quot;,          hurt: 10000,        },        {          name: &quot;十倍界王拳&quot;,          hurt: 5000,        }, {          name: &quot;元气弹&quot;,          hurt: 999999,        }      ]    };    person.skill.map(item =&gt; {      console.log(item.name + &quot;,&quot; +         item.hurt);    });</code></pre><h3 id="2-系统构造函数"><a href="#2-系统构造函数" class="headerlink" title="2. 系统构造函数"></a>2. 系统构造函数</h3><pre><code class="js">    let obj = new Object();    obj.name = &quot;John&quot;;    obj.age = 18;    obj.sayhi = function(){      console.log(&quot;Hello,I&#39;m John&quot;);    }</code></pre><blockquote><p>以上两种方式每次只能创建一个实例对象，当要创建多个相似对象时，存在代码冗余问题</p></blockquote><h3 id="3-工厂函数创建对象"><a href="#3-工厂函数创建对象" class="headerlink" title="3. 工厂函数创建对象"></a>3. 工厂函数创建对象</h3><pre><code class="js">   //可以传参数，提高代码复用，   function createStudent(name,age){       let student = new Object();       student.name = name;       student.age = age;       student.sayhi = function(){         console.log(&quot;Hello,I&#39;m &quot;+student.name);      }       return student;  }      //但是无法判读属于哪个对象。（instanceof）</code></pre><h3 id="4-自定义构造函数"><a href="#4-自定义构造函数" class="headerlink" title="4. 自定义构造函数"></a>4. 自定义构造函数</h3><pre><code class="js">    /**     * 自定义构造函数可以用instanceof判断属于哪个对象,且解决了代码复用问题，但是每个公共方法都会创建一个实例对象，造成内存浪费。     */    function Student(name,age){      this.name = name;      this.age = age;      this.sayHi = function(){        console.log(&quot;Hello,I&#39;m &quot; + this.name);      }    }</code></pre><h3 id="5-混合模式（构造函数模式-原型模式）"><a href="#5-混合模式（构造函数模式-原型模式）" class="headerlink" title="5. 混合模式（构造函数模式+原型模式）"></a>5. 混合模式（构造函数模式+原型模式）</h3><pre><code class="js">    /**    * 原型的作用，共享数据，节省内存，不同实例对象的sayHi方法都指向同一个    */    function Student(name,age){      this.name = name;      this.age = age;    }    Student.prototype = {      //将自身的prototype指向构造函数      constructor : Student,      sayHi:function(){        console.log(&quot;Hello,I&#39;m&quot; + this.name);      }    }</code></pre><h2 id="3-原型链"><a href="#3-原型链" class="headerlink" title="3. 原型链"></a>3. 原型链</h2><h3 id="1-构造函数的原型对象prototype"><a href="#1-构造函数的原型对象prototype" class="headerlink" title="1. 构造函数的原型对象prototype"></a>1. 构造函数的原型对象prototype</h3><p>每个函数<code>function Person()</code>为例，都有一个原型对象<strong>prototype</strong>，该原型对象默认存在两个属性，一个是<code>constructor</code>指向他的构造函数，即<code>Person()</code>，还有一个__ <strong>proto</strong> __，指向的是实例化Person的够构造函数的<strong>prototype</strong>，即<code>Function.prototype</code>，因为<code>function Person()</code> 相当于 <code>let Person = new Function()</code>。</p><pre><code class="js">    function Person(age) {      this.age = age;    }    let per = new Person(18);    console.dir(Person);    console.log(per.__proto__ === Person.prototype);//true</code></pre><p><img src="/Users/mac/myblog/public/img/yuanxinglian/prototype.png" srcset="/img/loading.gif" alt></p><h3 id="2-实例对象的原型对象-proto"><a href="#2-实例对象的原型对象-proto" class="headerlink" title="2. 实例对象的原型对象__ proto __"></a>2. 实例对象的原型对象__ <strong>proto</strong> __</h3><p>首先需要清除new的过程，因为实例化过程就是new Person()，需要清楚new这个过程发生的事情</p><pre><code class="js">     * new的过程经过了这几步     * 1. let obj = {};新建一个对象，开辟空间     * 2. obj.__proto__ = Person.prototype;将对象的__proto__指向构造函数的prototype     * 3. Person.call(obj); 执行构造函数中的代码，注意。此时的this为obj     * 4. 最后返回obj</code></pre><p>在new的过程中，obj.__ <strong>proto__</strong> 指向构造函数的<strong>prototype</strong>，所以每个实例对象都存在一个__ __ <strong>proto</strong> __属性，而这个属性就是指向构造函数的<strong>prototype</strong>对象。</p><p><img src="/Users/mac/myblog/public/img/yuanxinglian/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" srcset="/img/loading.gif" alt></p><h3 id="3-原型链的构成"><a href="#3-原型链的构成" class="headerlink" title="3.原型链的构成"></a>3.原型链的构成</h3><blockquote><p>小总结：</p><p>1.每个函数都存在<strong>prototype</strong>和__ <strong>proto</strong> __ 。每个实例对象都存在__ <strong>proto</strong> __ 。</p><p>2.原型链就是实例对象的__ <strong>proto</strong> __ 指向构造函数的<strong>prototype</strong> ,构造函数的<strong>prtotype.__ <strong>proto</strong> __</strong>指向Object.<strong>prototype</strong>,最后的Object.prototype.__ <strong>proto</strong> __指向<strong>null</strong>，而只要是在这条链上的属性或方法，</p><p>实例对象都能访问</p></blockquote><p>在js中，只要是在原型链(prototype)上的属性，在哪个环节都可以任意的调用,例子↓</p><pre><code class="js">    //构造函数    function Person(name){    this.name = name;  }    //在构造函数原型对象上添加方法    Person.prototype.run = function(){    console.log(&quot;跑步&quot;);  }    //在Function上定义一个方法    Object.prototype.printfName = function(){    console.log(this.name);  }    //实例化对象    let per = new Person(&quot;GZH&quot;);    //此时per可以调用run()方法    per.run();//跑步    //也可以调用printfName方法,因为prototype是new Object()，也就是prototype是Object的实例对象，所以prototype中的__proto__指向Object的prototype,所以printfName也在per的原型链上,可以访问    per.printfName();//GZH</code></pre><h3 id="4-原型对象的指向是可以被改变的"><a href="#4-原型对象的指向是可以被改变的" class="headerlink" title="4. 原型对象的指向是可以被改变的"></a>4. 原型对象的指向是可以被改变的</h3><p>因为prototype也是一个对象，所以他也可以指向任何对象，这也是继承的重要基础。</p><pre><code class="js">    function Person(name) {      this.name = name;    }        Person.prototype.run = function(){      console.log(&quot;跑步&quot;);    }        function Student() {       }        Student.prototype.study = function(){      console.log(&quot;学习&quot;);    }        let stu1 = new Student();        //可以访问study，因为study在原型链上        stu1.study();//学习        //改变Student的指向，此时Student.prototype = {age,__proto__(指向Person的prototype)}        Student.prorotype = new Person();        let stu2 = new Student();        stu2.run();//可以访问，因为run()方法在原型链上        stu2.study();//报错，因为原型链上已经发生改变</code></pre><blockquote><p>持续更新中….</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GraphQL+nodejs+mongodb的使用</title>
    <link href="undefined2019/09/29/GraphQL-nodejs-mongodb%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>2019/09/29/GraphQL-nodejs-mongodb%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>今天闲着没事就看了一下GraphQL，其实刚开始我也不知道是干嘛用的</p></blockquote><h1 id="GraphQL-一种用于-API-的查询语言"><a href="#GraphQL-一种用于-API-的查询语言" class="headerlink" title="GraphQL,一种用于 API 的查询语言"></a><a href="https://graphql.cn/" target="_blank" rel="noopener">GraphQL</a>,一种用于 API 的查询语言</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。也是就后端返回的数据可能有些你用不到(数据冗余)，你可以按需取得你想要的数据。没错，就是这么强大。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><blockquote><p>GraphQL可以用于许多后端语言，我用得的是nodejs+express框架+mongoDB。</p></blockquote><ol><li><p>首先需要<code>npm install --save -D express express-graphql graphql</code> ，如果已经添加了express环境，则可以把express去掉。</p></li><li><p>在你对应的路由下，引入<code>const graphqlHTTP = require(&#39;express-graphql&#39;)</code> ，我的是在分发的graphql路由下。基本代码如下。</p><pre><code class="js">//graphql.js//已下是固定模式const express = require(&quot;express&quot;);const router = express.Router();const graphqlHTTP = require(&#39;express-graphql&#39;);const defalutschema = require(&#39;../schema/defualtschema&#39;);//schemarouter.use(&#39;/&#39;, graphqlHTTP({  schema: defalutschema,//  graphiql: true,}));module.exports = router;</code></pre></li><li><p>在根目录下新建一个schema目录，在这个目录新建defualtschema.js文件，也就是graphql.js的<code>const defalutschema = require(&#39;../schema/defualtschema&#39;);</code>添加以下的代码;</p><pre><code class="js">//defualtschema.jsconst {  GraphQLObjectType,  GraphQLString,  GraphQLInt,  GraphQLList,  GraphQLSchema,  GraphQLScalarType} = require(&#39;graphql&#39;);//引入mongoose的模型，const Food = require(&#39;../db/model/foodModel&#39;);const User = require(&#39;../db/model/userModel&#39;);const mongoose = require(&#39;mongoose&#39;);//创建schema一般分3步// 1.定义需要查询的Schema类型，类型需要在graphql模块取出。请看👆let foodSchema = new GraphQLObjectType({  //名字  name: &#39;food&#39;,  //字段，类型需要跟数据库表一致，我的数据库表具体内容在下面贴出。  fields: {    _id: {      type: GraphQLString    },    foodName: {      type: GraphQLString    },    foodPrice: {      type: GraphQLString    },    foodDec: {      type: GraphQLString    },    foodType: {      type: GraphQLString    },    foodTypeID: {      type: GraphQLInt    },  }});// 2.定义一个根，根里面定义调用foodSchema类型的方法let rootSchema = new GraphQLObjectType({  name: &#39;root&#39;,  fields: {    //这里的字段相当于一个方法,这里是获取foodList(食物的全部数据)    foodList: {      type: GraphQLList(foodSchema),//是一个数组，需要用GraphQLList包裹      async resolve(parent, args) {        let foodList = await Food.find();//mongoose封装的方法，用于查找数据库数据        return foodList;//将查询到的数据返回      }    },  }});//3.导出，默认格式module.exports = new GraphQLSchema({  query: rootSchema});</code></pre></li></ol><ol start="4"><li><p>打开浏览器，输入url，就会看到，以下界面，在左边输入<code>{}</code>，里面写得就是<code>rootSchema</code>中定义的字段<code>fields</code>，这里输入foodList，然后选择<strong>左上角的播放按钮</strong></p><p><img src="/Users/mac/myblog/public/img/GraphQL/GraphQL1.png" srcset="/img/loading.gif" alt="图1"></p><p>就会得到以下内容，右边就是返回的数据。你可以在左边选择你需要的字段比如</p><pre><code class="js">{    foodList{        foodName        foodPrice        FoodDec    }}//在右边就可得到你想要数据,是不是很神奇！！！</code></pre><p><img src="/Users/mac/myblog/public/img/GraphQL/GraphQL2.png" srcset="/img/loading.gif" alt="图2"></p></li></ol><ol start="5"><li><p>传入参数(这里用ID)来获取食物的信息，修改<code>rootSchema</code>中代码</p><pre><code class="js">let rootSchema = new GraphQLObjectType({  name: &#39;root&#39;,  fields: {    //这里的字段相当于一个方法,这里是获取foodList(食物的全部数据)    foodList: ...,    //按id查询食物信息    getFoodById: {      type: foodSchema,        //参数：这里传入ID      args: {        ID: {          type: GraphQLString        }      },      async resolve(parent, args) {        let id = mongoose.Types.ObjectId(args.ID);        let foodInfo = await Food.find({          _id: id        })        return foodInfo[0];//这里需要注意，因为返回的是一个数组，但是这里需要对象。      }    },  }});</code></pre></li></ol><pre><code>   回到浏览器，在`getFoodById(...)`方法中传入参数ID:&quot;…..&quot;,这里参数名字要和服务端的参数一致。   ![图三](/Users/mac/myblog/public/img/GraphQL/graphQL3.png)   这就是GraphQL的基本用法。## 总结GraphQL入门还算是比较简单的，不过要深入还有许多内容可以学，还没有学习前端如何调用接口，明天继续学，继续加油。</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>GraphQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端启示录</title>
    <link href="undefined2019/09/28/%E5%89%8D%E7%AB%AF%E5%90%AF%E7%A4%BA%E5%BD%95/"/>
    <url>2019/09/28/%E5%89%8D%E7%AB%AF%E5%90%AF%E7%A4%BA%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="暑假的锻炼"><a href="#暑假的锻炼" class="headerlink" title="暑假的锻炼"></a>暑假的锻炼</h1><p>上学期学期末，有个老师的团队前端缺人，正在招新，那时候刚学习完html+css+js，算是入门吧，发现自己对前端方向还是挺有兴趣了，后来就去应聘了，后来也顺利进入了团队。</p><p>刚进入那会，以为前端不就写写html+css嘛，没多难，后来看了一下师兄写的工程源码，一脸懵逼，原来html标签还能在js里这么用，后来知道了师兄用得技术栈是react，这是一种jsx语法。</p><p>师兄给我们列了一张暑假学习清单。如下图。</p><p><img src="/Users/mac/myblog/public/img/target1.png" srcset="/img/loading.gif" alt="学习任务"></p><p><img src="/Users/mac/myblog/public/img/target2.png" srcset="/img/loading.gif" alt="学习任务"></p><p>师兄还创建了一个coding仓库，在上面发布任务，让我们完成。前面的任务还好，不过这种理论的东西对于我来说真的是很难记全，都是看着会，用时废，也就草草百度搜索复制粘贴答案应付任务，总感觉这东西我已经掌握了，但是就是不知道该运用在哪里，然后过几天学其他东西就又把新东西给忘了，效率着实低下。我还是比较喜欢偏实战一点，所以我经常观看up主用html+css做出来的炫酷效果，然后按着他的思路再自己敲一遍，这样就对一些css样式有了更深的理解。学习完第一周后收获还是蛮大的，加深了以前对html+css+js的理解</p><p>第二周的东西就会比较难一点，全是高级js的内容，理解起来确实有点困难，在B站看了尚硅谷的js进阶课程，感觉不错，我记得那时候死磕原型链，睡前都在想万物皆对象，有了下面这张图就就很好理解了。</p><p><img src="/Users/mac/myblog/public/img/yuanxinglian.png" srcset="/img/loading.gif" alt="原型链"></p><p>对于闭包，其实他的概念并不复杂，函数内部中的函数访问父函数中声明的变量，不过到现在我都不知道该如何合理的运用，或许是我还没掌握吧23333</p><pre><code class="js">function init() {    var name = &quot;Mozilla&quot;; // name 是一个被 init 创建的局部变量    function displayName() { // displayName() 是内部函数,一个闭包        alert(name); // 使用了父函数中声明的变量    }    displayName();</code></pre><p>还学习了伟大的<strong>ajax</strong>和<strong>json</strong>，解开了动态网站神秘面纱，以前写得都是静态页面，不过学习了伟大的ajax后，对前后端有了一个更深层次的认识。还有jQuery，做特效也太强了，插件库用起来太爽了。不过师兄跟我说现在jQuery快要淘汰了，了解基本的就可以，不用学太深，我一脸懵逼。。。。</p><p>第三周，跟着B站千峰前端的nodejs课程，入门了让前端革命的nodejs，真没想到，js也能用来写服务端👍。nodejs牛逼！！！</p><p>学习了sass，预编译器确实比原生的方便太多了，嵌套写法让看起来结构更加清晰等等。还有es6，ts，不过都是入门而已，时间紧迫。</p><p>第四周，React，前端三大框架之一，记得最痛苦的就是刚开始学react安装配置的各种插件，webpack，babel等，配置这东西太难了，跟着视频做，配完隔天就忘记，着实难受。后来才知道了create-react-app这个脚手架，真的是福音，开源牛逼。记得学习了差不多两个多星期了react，跟着视频老师做了一个react全家桶+antd小项目，有点成就感，后来自己也添加了许多功能上去，一步一步的完善。</p><p>五周的学习终于熬过了，9106的学习时间，不过确实学习到了许多了东西，这些技术都是现在的热门技术，这半个暑假算是过得充实。我以为学完就可以跟着师兄一起做项目了，问了师兄接下来有什么安排，他叫我们先继续学。问他学什么，他也说巩固一下前面的知识吧，很敷衍。顿时很迷茫，索性就回宿舍学习了，后来又学习react-native，这个技术安装遇到的问题可太多，而且是网上很难找到那种，也是以一个小项目结束了，算是入门了吧。这是项目都这我们github仓库，有兴趣了可以去看看喔。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这篇文章，我把暑假所学习到的东西给大概回忆了一下，算是对暑假的一个总结，同时也是对知识点的回顾。</p><blockquote><p>勿喷文采排版，正学习中…..</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用hexo搭建个人博客</title>
    <link href="undefined2019/09/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <url>2019/09/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<ul><li><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029" target="_blank" rel="noopener">一篇很详细的hexo教程</a></p></li><li><p>一路下来安装的都挺顺利，基本没有坑，这次选择了一个<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">Fluid模板</a> ，基于 <code>Material-Design</code>风格，看起来就很舒服</p></li><li><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">官方主题库，各种风格都有</a></p></li><li><p>不过部署在github上访问真的是太慢啦🙃🙃🙃🙃</p></li></ul><blockquote><p>第一篇博客不知道写点啥，文采太差了😬，希望以后能有所提升。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/09/27/hello-world/"/>
    <url>2019/09/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>