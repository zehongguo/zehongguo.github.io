<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>js高级复习</title>
    <link href="undefined2019/10/11/js%E9%AB%98%E7%BA%A7%E5%A4%8D%E4%B9%A0/"/>
    <url>2019/10/11/js%E9%AB%98%E7%BA%A7%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Javascript高级复习"><a href="#Javascript高级复习" class="headerlink" title="Javascript高级复习"></a>Javascript高级复习</h1><h2 id="1-new创建对象的本质"><a href="#1-new创建对象的本质" class="headerlink" title="1. new创建对象的本质"></a>1. new创建对象的本质</h2><pre><code class="JS">    function Person(name,age){      this.name = name;      this.age = age;      this.sayHi = function(){        return &quot;Hello,I&#39;m&quot; + this.name;      }    }    let John = new Person(name,age);    /**     * new的过程经过了这几步     * 1. let obj = {};新建一个对象，开辟空间     * 2. obj.__proto__ = Person.prototype;将对象的__proto__指向构造函数的prototype     * 3. Person.call(obj); 执行构造函数中的代码，注意。此时的this为obj     * 4. 最后返回obj     *     */</code></pre><h2 id="2-几种常见的对象创建方式"><a href="#2-几种常见的对象创建方式" class="headerlink" title="2. 几种常见的对象创建方式"></a>2. 几种常见的对象创建方式</h2><h3 id="1-字面量创建方式"><a href="#1-字面量创建方式" class="headerlink" title="1. 字面量创建方式"></a>1. 字面量创建方式</h3><pre><code class="js">    let person = {      name: &quot;孙悟空&quot;,      age: 100,      sex: 1,      power: 10000,      skill: [{          name: &quot;龟派气功&quot;,          hurt: 10000,        },        {          name: &quot;十倍界王拳&quot;,          hurt: 5000,        }, {          name: &quot;元气弹&quot;,          hurt: 999999,        }      ]    };    person.skill.map(item =&gt; {      console.log(item.name + &quot;,&quot; +         item.hurt);    });</code></pre><h3 id="2-系统构造函数"><a href="#2-系统构造函数" class="headerlink" title="2. 系统构造函数"></a>2. 系统构造函数</h3><pre><code class="js">    let obj = new Object();    obj.name = &quot;John&quot;;    obj.age = 18;    obj.sayhi = function(){      console.log(&quot;Hello,I&#39;m John&quot;);    }</code></pre><blockquote><p>以上两种方式每次只能创建一个实例对象，当要创建多个相似对象时，存在代码冗余问题</p></blockquote><h3 id="3-工厂函数创建对象"><a href="#3-工厂函数创建对象" class="headerlink" title="3. 工厂函数创建对象"></a>3. 工厂函数创建对象</h3><pre><code class="js">   //可以传参数，提高代码复用，   function createStudent(name,age){       let student = new Object();       student.name = name;       student.age = age;       student.sayhi = function(){         console.log(&quot;Hello,I&#39;m &quot;+student.name);      }       return student;  }      //但是无法判读属于哪个对象。（instanceof）</code></pre><h3 id="4-自定义构造函数"><a href="#4-自定义构造函数" class="headerlink" title="4. 自定义构造函数"></a>4. 自定义构造函数</h3><pre><code class="js">    /**     * 自定义构造函数可以用instanceof判断属于哪个对象,且解决了代码复用问题，但是每个公共方法都会创建一个实例对象，造成内存浪费。     */    function Student(name,age){      this.name = name;      this.age = age;      this.sayHi = function(){        console.log(&quot;Hello,I&#39;m &quot; + this.name);      }    }</code></pre><h3 id="5-混合模式（构造函数模式-原型模式）"><a href="#5-混合模式（构造函数模式-原型模式）" class="headerlink" title="5. 混合模式（构造函数模式+原型模式）"></a>5. 混合模式（构造函数模式+原型模式）</h3><pre><code class="js">    /**    * 原型的作用，共享数据，节省内存，不同实例对象的sayHi方法都指向同一个    */    function Student(name,age){      this.name = name;      this.age = age;    }    Student.prototype = {      //将自身的prototype指向构造函数      constructor : Student,      sayHi:function(){        console.log(&quot;Hello,I&#39;m&quot; + this.name);      }    }</code></pre><h2 id="3-原型链"><a href="#3-原型链" class="headerlink" title="3. 原型链"></a>3. 原型链</h2><h3 id="1-构造函数的原型对象prototype"><a href="#1-构造函数的原型对象prototype" class="headerlink" title="1. 构造函数的原型对象prototype"></a>1. 构造函数的原型对象prototype</h3><p>每个函数<code>function Person()</code>为例，都有一个原型对象<strong>prototype</strong>，该原型对象默认存在两个属性，一个是<code>constructor</code>指向他的构造函数，即<code>Person()</code>，还有一个__ <strong>proto</strong> __，指向的是实例化Person的够构造函数的<strong>prototype</strong>，即<code>Function.prototype</code>，因为<code>function Person()</code> 相当于 <code>let Person = new Function()</code>。</p><pre><code class="js">    function Person(age) {      this.age = age;    }    let per = new Person(18);    console.dir(Person);    console.log(per.__proto__ === Person.prototype);//true</code></pre><p><img src="/Users/mac/myblog/public/img/yuanxinglian/prototype.png" srcset="/img/loading.gif" alt></p><h3 id="2-实例对象的原型对象-proto"><a href="#2-实例对象的原型对象-proto" class="headerlink" title="2. 实例对象的原型对象__ proto __"></a>2. 实例对象的原型对象__ <strong>proto</strong> __</h3><p>首先需要清除new的过程，因为实例化过程就是new Person()，需要清楚new这个过程发生的事情</p><pre><code class="js">     * new的过程经过了这几步     * 1. let obj = {};新建一个对象，开辟空间     * 2. obj.__proto__ = Person.prototype;将对象的__proto__指向构造函数的prototype     * 3. Person.call(obj); 执行构造函数中的代码，注意。此时的this为obj     * 4. 最后返回obj</code></pre><p>在new的过程中，obj.__ <strong>proto__</strong> 指向构造函数的<strong>prototype</strong>，所以每个实例对象都存在一个__ __ <strong>proto</strong> __属性，而这个属性就是指向构造函数的<strong>prototype</strong>对象。</p><p><img src="/Users/mac/myblog/public/img/yuanxinglian/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" srcset="/img/loading.gif" alt></p><h3 id="3-原型链的构成"><a href="#3-原型链的构成" class="headerlink" title="3.原型链的构成"></a>3.原型链的构成</h3><blockquote><p>小总结：</p><p>1.每个函数都存在<strong>prototype</strong>和__ <strong>proto</strong> __ 。每个实例对象都存在__ <strong>proto</strong> __ 。</p><p>2.原型链就是实例对象的__ <strong>proto</strong> __ 指向构造函数的<strong>prototype</strong> ,构造函数的<strong>prtotype.__ <strong>proto</strong> __</strong>指向Object.<strong>prototype</strong>,最后的Object.prototype.__ <strong>proto</strong> __指向<strong>null</strong>，而只要是在这条链上的属性或方法，</p><p>实例对象都能访问</p></blockquote><p>在js中，只要是在原型链(prototype)上的属性，在哪个环节都可以任意的调用,例子↓</p><pre><code class="js">    //构造函数    function Person(name){    this.name = name;  }    //在构造函数原型对象上添加方法    Person.prototype.run = function(){    console.log(&quot;跑步&quot;);  }    //在Function上定义一个方法    Object.prototype.printfName = function(){    console.log(this.name);  }    //实例化对象    let per = new Person(&quot;GZH&quot;);    //此时per可以调用run()方法    per.run();//跑步    //也可以调用printfName方法,因为prototype是new Object()，也就是prototype是Object的实例对象，所以prototype中的__proto__指向Object的prototype,所以printfName也在per的原型链上,可以访问    per.printfName();//GZH</code></pre><h3 id="4-原型对象的指向是可以被改变的"><a href="#4-原型对象的指向是可以被改变的" class="headerlink" title="4. 原型对象的指向是可以被改变的"></a>4. 原型对象的指向是可以被改变的</h3><p>因为prototype也是一个对象，所以他也可以指向任何对象，这也是继承的重要基础。</p><pre><code class="js">    function Person(name) {      this.name = name;    }        Person.prototype.run = function(){      console.log(&quot;跑步&quot;);    }        function Student() {       }        Student.prototype.study = function(){      console.log(&quot;学习&quot;);    }        let stu1 = new Student();        //可以访问study，因为study在原型链上        stu1.study();//学习        //改变Student的指向，此时Student.prototype = {age,__proto__(指向Person的prototype)}        Student.prorotype = new Person();        let stu2 = new Student();        stu2.run();//可以访问，因为run()方法在原型链上        stu2.study();//报错，因为原型链上已经发生改变</code></pre><blockquote><p>持续更新中….</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GraphQL+nodejs+mongodb的使用</title>
    <link href="undefined2019/09/29/GraphQL-nodejs-mongodb%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>2019/09/29/GraphQL-nodejs-mongodb%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>今天闲着没事就看了一下GraphQL，其实刚开始我也不知道是干嘛用的</p></blockquote><h1 id="GraphQL-一种用于-API-的查询语言"><a href="#GraphQL-一种用于-API-的查询语言" class="headerlink" title="GraphQL,一种用于 API 的查询语言"></a><a href="https://graphql.cn/" target="_blank" rel="noopener">GraphQL</a>,一种用于 API 的查询语言</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。也是就后端返回的数据可能有些你用不到(数据冗余)，你可以按需取得你想要的数据。没错，就是这么强大。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><blockquote><p>GraphQL可以用于许多后端语言，我用得的是nodejs+express框架+mongoDB。</p></blockquote><ol><li><p>首先需要<code>npm install --save -D express express-graphql graphql</code> ，如果已经添加了express环境，则可以把express去掉。</p></li><li><p>在你对应的路由下，引入<code>const graphqlHTTP = require(&#39;express-graphql&#39;)</code> ，我的是在分发的graphql路由下。基本代码如下。</p><pre><code class="js">//graphql.js//已下是固定模式const express = require(&quot;express&quot;);const router = express.Router();const graphqlHTTP = require(&#39;express-graphql&#39;);const defalutschema = require(&#39;../schema/defualtschema&#39;);//schemarouter.use(&#39;/&#39;, graphqlHTTP({  schema: defalutschema,//  graphiql: true,}));module.exports = router;</code></pre></li><li><p>在根目录下新建一个schema目录，在这个目录新建defualtschema.js文件，也就是graphql.js的<code>const defalutschema = require(&#39;../schema/defualtschema&#39;);</code>添加以下的代码;</p><pre><code class="js">//defualtschema.jsconst {  GraphQLObjectType,  GraphQLString,  GraphQLInt,  GraphQLList,  GraphQLSchema,  GraphQLScalarType} = require(&#39;graphql&#39;);//引入mongoose的模型，const Food = require(&#39;../db/model/foodModel&#39;);const User = require(&#39;../db/model/userModel&#39;);const mongoose = require(&#39;mongoose&#39;);//创建schema一般分3步// 1.定义需要查询的Schema类型，类型需要在graphql模块取出。请看👆let foodSchema = new GraphQLObjectType({  //名字  name: &#39;food&#39;,  //字段，类型需要跟数据库表一致，我的数据库表具体内容在下面贴出。  fields: {    _id: {      type: GraphQLString    },    foodName: {      type: GraphQLString    },    foodPrice: {      type: GraphQLString    },    foodDec: {      type: GraphQLString    },    foodType: {      type: GraphQLString    },    foodTypeID: {      type: GraphQLInt    },  }});// 2.定义一个根，根里面定义调用foodSchema类型的方法let rootSchema = new GraphQLObjectType({  name: &#39;root&#39;,  fields: {    //这里的字段相当于一个方法,这里是获取foodList(食物的全部数据)    foodList: {      type: GraphQLList(foodSchema),//是一个数组，需要用GraphQLList包裹      async resolve(parent, args) {        let foodList = await Food.find();//mongoose封装的方法，用于查找数据库数据        return foodList;//将查询到的数据返回      }    },  }});//3.导出，默认格式module.exports = new GraphQLSchema({  query: rootSchema});</code></pre></li></ol><ol start="4"><li><p>打开浏览器，输入url，就会看到，以下界面，在左边输入<code>{}</code>，里面写得就是<code>rootSchema</code>中定义的字段<code>fields</code>，这里输入foodList，然后选择<strong>左上角的播放按钮</strong></p><p><img src="/Users/mac/myblog/public/img/GraphQL/GraphQL1.png" srcset="/img/loading.gif" alt="图1"></p><p>就会得到以下内容，右边就是返回的数据。你可以在左边选择你需要的字段比如</p><pre><code class="js">{    foodList{        foodName        foodPrice        FoodDec    }}//在右边就可得到你想要数据,是不是很神奇！！！</code></pre><p><img src="/Users/mac/myblog/public/img/GraphQL/GraphQL2.png" srcset="/img/loading.gif" alt="图2"></p></li></ol><ol start="5"><li><p>传入参数(这里用ID)来获取食物的信息，修改<code>rootSchema</code>中代码</p><pre><code class="js">let rootSchema = new GraphQLObjectType({  name: &#39;root&#39;,  fields: {    //这里的字段相当于一个方法,这里是获取foodList(食物的全部数据)    foodList: ...,    //按id查询食物信息    getFoodById: {      type: foodSchema,        //参数：这里传入ID      args: {        ID: {          type: GraphQLString        }      },      async resolve(parent, args) {        let id = mongoose.Types.ObjectId(args.ID);        let foodInfo = await Food.find({          _id: id        })        return foodInfo[0];//这里需要注意，因为返回的是一个数组，但是这里需要对象。      }    },  }});</code></pre></li></ol><pre><code>   回到浏览器，在`getFoodById(...)`方法中传入参数ID:&quot;…..&quot;,这里参数名字要和服务端的参数一致。   ![图三](/Users/mac/myblog/public/img/GraphQL/graphQL3.png)   这就是GraphQL的基本用法。## 总结GraphQL入门还算是比较简单的，不过要深入还有许多内容可以学，还没有学习前端如何调用接口，明天继续学，继续加油。</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>GraphQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端启示录</title>
    <link href="undefined2019/09/28/%E5%89%8D%E7%AB%AF%E5%90%AF%E7%A4%BA%E5%BD%95/"/>
    <url>2019/09/28/%E5%89%8D%E7%AB%AF%E5%90%AF%E7%A4%BA%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="暑假的锻炼"><a href="#暑假的锻炼" class="headerlink" title="暑假的锻炼"></a>暑假的锻炼</h1><p>上学期学期末，有个老师的团队前端缺人，正在招新，那时候刚学习完html+css+js，算是入门吧，发现自己对前端方向还是挺有兴趣了，后来就去应聘了，后来也顺利进入了团队。</p><p>刚进入那会，以为前端不就写写html+css嘛，没多难，后来看了一下师兄写的工程源码，一脸懵逼，原来html标签还能在js里这么用，后来知道了师兄用得技术栈是react，这是一种jsx语法。</p><p>师兄给我们列了一张暑假学习清单。如下图。</p><p><img src="/Users/mac/myblog/public/img/target1.png" srcset="/img/loading.gif" alt="学习任务"></p><p><img src="/Users/mac/myblog/public/img/target2.png" srcset="/img/loading.gif" alt="学习任务"></p><p>师兄还创建了一个coding仓库，在上面发布任务，让我们完成。前面的任务还好，不过这种理论的东西对于我来说真的是很难记全，都是看着会，用时废，也就草草百度搜索复制粘贴答案应付任务，总感觉这东西我已经掌握了，但是就是不知道该运用在哪里，然后过几天学其他东西就又把新东西给忘了，效率着实低下。我还是比较喜欢偏实战一点，所以我经常观看up主用html+css做出来的炫酷效果，然后按着他的思路再自己敲一遍，这样就对一些css样式有了更深的理解。学习完第一周后收获还是蛮大的，加深了以前对html+css+js的理解</p><p>第二周的东西就会比较难一点，全是高级js的内容，理解起来确实有点困难，在B站看了尚硅谷的js进阶课程，感觉不错，我记得那时候死磕原型链，睡前都在想万物皆对象，有了下面这张图就就很好理解了。</p><p><img src="/Users/mac/myblog/public/img/yuanxinglian.png" srcset="/img/loading.gif" alt="原型链"></p><p>对于闭包，其实他的概念并不复杂，函数内部中的函数访问父函数中声明的变量，不过到现在我都不知道该如何合理的运用，或许是我还没掌握吧23333</p><pre><code class="js">function init() {    var name = &quot;Mozilla&quot;; // name 是一个被 init 创建的局部变量    function displayName() { // displayName() 是内部函数,一个闭包        alert(name); // 使用了父函数中声明的变量    }    displayName();</code></pre><p>还学习了伟大的<strong>ajax</strong>和<strong>json</strong>，解开了动态网站神秘面纱，以前写得都是静态页面，不过学习了伟大的ajax后，对前后端有了一个更深层次的认识。还有jQuery，做特效也太强了，插件库用起来太爽了。不过师兄跟我说现在jQuery快要淘汰了，了解基本的就可以，不用学太深，我一脸懵逼。。。。</p><p>第三周，跟着B站千峰前端的nodejs课程，入门了让前端革命的nodejs，真没想到，js也能用来写服务端👍。nodejs牛逼！！！</p><p>学习了sass，预编译器确实比原生的方便太多了，嵌套写法让看起来结构更加清晰等等。还有es6，ts，不过都是入门而已，时间紧迫。</p><p>第四周，React，前端三大框架之一，记得最痛苦的就是刚开始学react安装配置的各种插件，webpack，babel等，配置这东西太难了，跟着视频做，配完隔天就忘记，着实难受。后来才知道了create-react-app这个脚手架，真的是福音，开源牛逼。记得学习了差不多两个多星期了react，跟着视频老师做了一个react全家桶+antd小项目，有点成就感，后来自己也添加了许多功能上去，一步一步的完善。</p><p>五周的学习终于熬过了，9106的学习时间，不过确实学习到了许多了东西，这些技术都是现在的热门技术，这半个暑假算是过得充实。我以为学完就可以跟着师兄一起做项目了，问了师兄接下来有什么安排，他叫我们先继续学。问他学什么，他也说巩固一下前面的知识吧，很敷衍。顿时很迷茫，索性就回宿舍学习了，后来又学习react-native，这个技术安装遇到的问题可太多，而且是网上很难找到那种，也是以一个小项目结束了，算是入门了吧。这是项目都这我们github仓库，有兴趣了可以去看看喔。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这篇文章，我把暑假所学习到的东西给大概回忆了一下，算是对暑假的一个总结，同时也是对知识点的回顾。</p><blockquote><p>勿喷文采排版，正学习中…..</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用hexo搭建个人博客</title>
    <link href="undefined2019/09/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <url>2019/09/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<ul><li><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029" target="_blank" rel="noopener">一篇很详细的hexo教程</a></p></li><li><p>一路下来安装的都挺顺利，基本没有坑，这次选择了一个<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">Fluid模板</a> ，基于 <code>Material-Design</code>风格，看起来就很舒服</p></li><li><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">官方主题库，各种风格都有</a></p></li><li><p>不过部署在github上访问真的是太慢啦🙃🙃🙃🙃</p></li></ul><blockquote><p>第一篇博客不知道写点啥，文采太差了😬，希望以后能有所提升。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/09/27/hello-world/"/>
    <url>2019/09/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>