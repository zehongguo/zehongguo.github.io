<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>js高级复习2</title>
    <link href="undefined2019/10/24/js%E9%AB%98%E7%BA%A72/"/>
    <url>2019/10/24/js%E9%AB%98%E7%BA%A72/</url>
    
    <content type="html"><![CDATA[<h1 id="js高级复习2"><a href="#js高级复习2" class="headerlink" title="js高级复习2"></a>js高级复习2</h1><h2 id="4-继承"><a href="#4-继承" class="headerlink" title="4. 继承"></a>4. 继承</h2><h3 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h3><pre><code class="js">    //父类 人类 --- 姓名，年龄，性别， -行为- 吃，玩    //子类 学生 --- 姓名，年龄，性别， -行为- 吃，玩，学习    function Person(name, age, sex) {      this.name = name;      this.age = age;      this.sex = sex || 1;    }    Person.prototype.eat = function () {      console.log(this.name + &quot;吃东西&quot;);    }    Person.prototype.play = function () {      console.log(this.name + &quot;玩&quot;)    }    function Student(sorce) {      this.sorce = sorce;    }    Student.prototype = new Person(&quot;小明&quot;, 18, 1);    Student.prototype.study = function () {      console.log(this.name + &quot;在学习&quot;);    }    let stu = new Student(&quot;100&quot;);    console.dir(stu);    stu.study();</code></pre><blockquote><p>优点：优点是继承了父类的模板，又继承了父类的原型对象</p><p> 缺点：对象属性固定，修改起来麻烦；例如连续创建几个学生实例对象，名字都是相同，要改则需要用stu.name = “…”，这样修改。</p></blockquote><h3 id="2-借用构造函数修改"><a href="#2-借用构造函数修改" class="headerlink" title="2. 借用构造函数修改"></a>2. 借用构造函数修改</h3><pre><code class="js">function Person(name, age, sex) {  this.name = name;  this.age = age;  this.sex = sex;}Person.prototype.eat = function () {  console.log(&quot;吃饭饭&quot;);};function Student(name, age, sex, score) {  Person.call(this, name, age, sex);//利用call的方法执行Person构造函数，初始化属性  this.score = score;}let stu = new Student(&quot;小明&quot;, 18, &quot;男&quot;, 100);stu.eat();</code></pre><blockquote><p>优点：比原型链继承更加灵活，实例对象时即可初始化自身属性</p><p>缺点：无法访问父类的prototype方法</p></blockquote><h3 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h3><pre><code class="js">// 借用组合继承（原型继承+借用构造函数继承）function Person(name, age, sex) {  this.name = name;  this.age = age;  this.sex = sex;}Person.prototype.eat = function () {  console.log(&quot;吃饭饭&quot;);};function Student(name, age, sex, score) {  Person.call(this, name, age, sex);  this.score = score;}Student.prototype = new Person();//改变原型指向Student.prototype.constructor = Student;//将构造函数指向本身let stu = new Student(&quot;小明&quot;, 18, &quot;男&quot;, 100);stu.eat();</code></pre><blockquote><p>优点：结合原型链继承和借用构造函数继承，就完美地解决了之前这二者各自表现出来的缺点。即可继承属性，又可继承方法</p><p>缺点：Person()方法执行了两次，一次 Person.call(this, name, age, sex);一次new Person();</p></blockquote><h3 id="4-拷贝继承"><a href="#4-拷贝继承" class="headerlink" title="4.拷贝继承"></a>4.拷贝继承</h3><pre><code class="js">//1.赋值，无开辟新空间let obj = {  name:&quot;Gzh&quot;,  age:18}let obj1 = obj;//2.开辟了新空间function Person() {}Person.prototype.name = &quot;阿萨德&quot;;Person.prototype.age = 18;Person.prototype.sex = &quot;男&quot;;Person.prototype.sayHi = function () {  console.log(&quot;hello&quot;);};let student = {};for (let key in Person.prototype) {  student[key] = Person.prototype[key];}</code></pre><blockquote><p>优点：支持多继承</p><p>缺点：1、效率较低，内存占用高（因为要拷贝父类的属性）</p><p>​            2、无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</p></blockquote><h3 id="5-寄生组合继承"><a href="#5-寄生组合继承" class="headerlink" title="5. 寄生组合继承"></a>5. 寄生组合继承</h3><pre><code class="js">    function Person(name, age, sex) {      this.name = name;      this.age = age;      this.sex = sex;    }    Person.prototype.eat = function () {      console.log(this.name + &quot;在吃饭&quot;);    }    function Student(name, age, sex, grade) {      Person.call(this, name, age, sex);      this.grade = grade;    }    (function () {      function Super() {};      Super.prototype = Person.prototype;      console.log(Super);      Student.prototype = new Super();    })();    let stu = new Student(&quot;wassupbro&quot;, 18, &quot;男&quot;, &quot;大二&quot;);    stu.eat();//wassupbro在吃饭    console.dir(stu);</code></pre><blockquote><p>优点：既可以继承属性，又可以继承方法，也只执行了一次Person的构造函数，堪称完美</p><p>缺点：实现起来稍复杂</p></blockquote><h2 id="5-call、apply、bind方法"><a href="#5-call、apply、bind方法" class="headerlink" title="5.call、apply、bind方法"></a>5.call、apply、bind方法</h2><h3 id="1-js中this指向问题"><a href="#1-js中this指向问题" class="headerlink" title="1. js中this指向问题"></a>1. js中this指向问题</h3><h4 id="1-在全局环境中"><a href="#1-在全局环境中" class="headerlink" title="1. 在全局环境中"></a>1. 在全局环境中</h4><p>在全局执行环境中（在任何函数体外部），this都是指向全局对象。在浏览器中，window对象即是全局对象;</p><pre><code class="js">console.log(this); //Windowvar a = 1;console.log(window.a);  //1</code></pre><h4 id="2-在函数环境中"><a href="#2-在函数环境中" class="headerlink" title="2.在函数环境中"></a>2.在函数环境中</h4><p> 在函数内容，this指向取决于函数调用的方式;</p><pre><code class="js">function f(){&quot;use strict&quot;; //使用严格模式console.log(this); } f(); // window ；使用严格模式时，输出undefined</code></pre><h4 id="3-作为对象的方法调用时"><a href="#3-作为对象的方法调用时" class="headerlink" title="3. 作为对象的方法调用时"></a>3. 作为对象的方法调用时</h4><p>当函数作为对象的方法被调用时，this指向调用的该函数的对象;</p><pre><code class="js">var obj = {  a: 37,  fn: function() {    return this.a;  }};console.log(obj.fn());  // 37</code></pre><h4 id="4-作为构造函数"><a href="#4-作为构造函数" class="headerlink" title="4.作为构造函数"></a>4.作为构造函数</h4><p>当一个函数用作构造函数时（使用new关键字），它的<code>this</code>被绑定到正在构造的新对象。</p><p><strong>虽然构造器返回的默认值是this所指的那个对象，但它仍可以手动返回其他的对象（如果返回值不是一个对象，则返回this对象）。</strong></p><pre><code class="js">function C(){  this.a = 37;}var o = new C();console.log(o.a); //  37function C2(){  this.a = 37;  return {a:38};}o = new C2();console.log(o.a); //  38，手动设置了返回对象</code></pre><h4 id="5-作为DOM事件处理函数"><a href="#5-作为DOM事件处理函数" class="headerlink" title="5.作为DOM事件处理函数"></a>5.作为DOM事件处理函数</h4><p>当函数被用作事件处理函数时，它的<code>this</code>指向触发事件的元素（一些浏览器在使用非<code>addEventListener</code>的函数动态添加监听函数时不遵守这个约定）。</p><h3 id="2-call和apply方法"><a href="#2-call和apply方法" class="headerlink" title="2. call和apply方法"></a>2. call和apply方法</h3><ul><li>作用：用来改变函数中this的指向</li><li>用法：Person.call(对象，参数1，参数2,…);Person.apply(对象，[参数1，参数2,…])</li><li>使用：需要调用其他对象的方法，并且this指向自身时；</li><li>实例,下面的例子↓</li></ul><pre><code class="js">function Person(name, age) {  this.name = name;  this.age = age;}Person.prototype.eat = function () {  console.log(this.name + &quot;在吃饭&quot;);};let obj = {  name: &quot;gzh&quot;,  age: 18};let per = new Person(&quot;htat&quot;, 18);per.eat(); //htat在吃饭per.eat.call(obj); //gzh在吃饭，改变了this的指向</code></pre><h3 id="3-bind方法"><a href="#3-bind方法" class="headerlink" title="3.bind方法"></a>3.bind方法</h3><ul><li><p>作用：改变this指向，复制一份到变量</p></li><li><p>实例</p><pre><code class="js">let obj = {  name: &quot;gzh&quot;,  age: 18,  eat: function () {    console.log(this.name);  }};let obj2 = {  name: &quot;http&quot;};obj2.eat = obj.eat.bind(obj2); //改变了this的指向并将eat方法复制给obj2.eatobj2.eat();//http</code></pre></li></ul><h3 id="6-闭包"><a href="#6-闭包" class="headerlink" title="6.闭包"></a>6.闭包</h3><ul><li><p>概念：函数A内的数据可以被函数B访问</p></li><li><p>模式：函数闭包，对象模式的闭包</p></li><li><p>作用：缓存数据，延长作用域；私有化变量</p></li><li><p>缺点：可能会造成数据泄露</p></li></ul><pre><code class="js">//例子：//函数模式闭包function f3() {  let num = 10;  return function () {    return ++num;  };}let f4 = f3();console.log(f4());//11 num没有被系统回收console.log(f4());//12console.log(f4());//13//对象模式闭包function f2() {  let num = 20;  let obj = {    age: num,  };  return obj;}console.log(f2().age);//函数外可以访问到f2中的变量，</code></pre><p>利用闭包实现一个点赞的案例</p><pre><code class="js">    &lt;input type=&quot;button&quot; value=&quot;点赞(1)&quot;&gt;  &lt;input type=&quot;button&quot; value=&quot;点赞(1)&quot;&gt;  &lt;input type=&quot;button&quot; value=&quot;点赞(1)&quot;&gt;  &lt;input type=&quot;button&quot; value=&quot;点赞(1)&quot;&gt;  &lt;script&gt;    let btnArr = document.getElementsByTagName(&quot;input&quot;);    for (let i = 0; i &lt; btnArr.length; i++) {      let value = 1;      btnArr[i].onclick = function () {        this.value = &quot;点赞(&quot; + (++value) + &quot;)&quot;;//注册点击事件，可以访问到value      }    }  &lt;/script&gt;</code></pre><h3 id="7-沙箱"><a href="#7-沙箱" class="headerlink" title="7. 沙箱"></a>7. 沙箱</h3><p>概念：<em>沙箱 就是形成一个密闭的环境 不能 主动的影响外界</em>，在js中就是自执行函数</p><p>作用：新建一块可用于模块运行的环境(沙箱)，自己的代码放在回调函数里，且不会对其他的个人沙箱造成影响</p><pre><code class="js">let num = 1000;((function(){  //在自执行函数中有自己的作用域  let num = 10;  console.log(num);//10})())console.log(num);//1000</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>js高级复习1</title>
    <link href="undefined2019/10/11/js%E9%AB%98%E7%BA%A7%E5%A4%8D%E4%B9%A0/"/>
    <url>2019/10/11/js%E9%AB%98%E7%BA%A7%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Javascript高级复习"><a href="#Javascript高级复习" class="headerlink" title="Javascript高级复习"></a>Javascript高级复习</h1><h2 id="1-new创建对象的本质"><a href="#1-new创建对象的本质" class="headerlink" title="1. new创建对象的本质"></a>1. new创建对象的本质</h2><pre><code class="JS">    function Person(name,age){      this.name = name;      this.age = age;      this.sayHi = function(){        return &quot;Hello,I&#39;m&quot; + this.name;      }    }    let John = new Person(name,age);    /**     * new的过程经过了这几步     * 1. let obj = {};新建一个对象，开辟空间     * 2. obj.__proto__ = Person.prototype;将对象的__proto__指向构造函数的prototype     * 3. Person.call(obj); 执行构造函数中的代码，注意。此时的this为obj     * 4. 最后返回obj     *     */</code></pre><h2 id="2-几种常见的对象创建方式"><a href="#2-几种常见的对象创建方式" class="headerlink" title="2. 几种常见的对象创建方式"></a>2. 几种常见的对象创建方式</h2><h3 id="1-字面量创建方式"><a href="#1-字面量创建方式" class="headerlink" title="1. 字面量创建方式"></a>1. 字面量创建方式</h3><pre><code class="js">    let person = {      name: &quot;孙悟空&quot;,      age: 100,      sex: 1,      power: 10000,      skill: [{          name: &quot;龟派气功&quot;,          hurt: 10000,        },        {          name: &quot;十倍界王拳&quot;,          hurt: 5000,        }, {          name: &quot;元气弹&quot;,          hurt: 999999,        }      ]    };    person.skill.map(item =&gt; {      console.log(item.name + &quot;,&quot; +         item.hurt);    });</code></pre><h3 id="2-系统构造函数"><a href="#2-系统构造函数" class="headerlink" title="2. 系统构造函数"></a>2. 系统构造函数</h3><pre><code class="js">    let obj = new Object();    obj.name = &quot;John&quot;;    obj.age = 18;    obj.sayhi = function(){      console.log(&quot;Hello,I&#39;m John&quot;);    }</code></pre><blockquote><p>以上两种方式每次只能创建一个实例对象，当要创建多个相似对象时，存在代码冗余问题</p></blockquote><h3 id="3-工厂函数创建对象"><a href="#3-工厂函数创建对象" class="headerlink" title="3. 工厂函数创建对象"></a>3. 工厂函数创建对象</h3><pre><code class="js">   //可以传参数，提高代码复用，   function createStudent(name,age){       let student = new Object();       student.name = name;       student.age = age;       student.sayhi = function(){         console.log(&quot;Hello,I&#39;m &quot;+student.name);      }       return student;  }      //但是无法判读属于哪个对象。（instanceof）</code></pre><h3 id="4-自定义构造函数"><a href="#4-自定义构造函数" class="headerlink" title="4. 自定义构造函数"></a>4. 自定义构造函数</h3><pre><code class="js">    /**     * 自定义构造函数可以用instanceof判断属于哪个对象,且解决了代码复用问题，但是每个公共方法都会创建一个实例对象，造成内存浪费。     */    function Student(name,age){      this.name = name;      this.age = age;      this.sayHi = function(){        console.log(&quot;Hello,I&#39;m &quot; + this.name);      }    }</code></pre><h3 id="5-混合模式（构造函数模式-原型模式）"><a href="#5-混合模式（构造函数模式-原型模式）" class="headerlink" title="5. 混合模式（构造函数模式+原型模式）"></a>5. 混合模式（构造函数模式+原型模式）</h3><pre><code class="js">    /**    * 原型的作用，共享数据，节省内存，不同实例对象的sayHi方法都指向同一个    */    function Student(name,age){      this.name = name;      this.age = age;    }    Student.prototype = {      //将自身的prototype指向构造函数      constructor : Student,      sayHi:function(){        console.log(&quot;Hello,I&#39;m&quot; + this.name);      }    }</code></pre><h2 id="3-原型链"><a href="#3-原型链" class="headerlink" title="3. 原型链"></a>3. 原型链</h2><h3 id="1-构造函数的原型对象prototype"><a href="#1-构造函数的原型对象prototype" class="headerlink" title="1. 构造函数的原型对象prototype"></a>1. 构造函数的原型对象prototype</h3><p>每个函数<code>function Person()</code>为例，都有一个原型对象<strong>prototype</strong>，该原型对象默认存在两个属性，一个是<code>constructor</code>指向他的构造函数，即<code>Person()</code>，还有一个__ <strong>proto</strong> __，指向的是实例化Person的够构造函数的<strong>prototype</strong>，即<code>Function.prototype</code>，因为<code>function Person()</code> 相当于 <code>let Person = new Function()</code>。</p><pre><code class="js">    function Person(age) {      this.age = age;    }    let per = new Person(18);    console.dir(Person);    console.log(per.__proto__ === Person.prototype);//true</code></pre><p><img src="/Users/mac/myblog/public/img/yuanxinglian/prototype.png" srcset="/img/loading.gif" alt></p><h3 id="2-实例对象的原型对象-proto"><a href="#2-实例对象的原型对象-proto" class="headerlink" title="2. 实例对象的原型对象__ proto __"></a>2. 实例对象的原型对象__ <strong>proto</strong> __</h3><p>首先需要清除new的过程，因为实例化过程就是new Person()，需要清楚new这个过程发生的事情</p><pre><code class="js">     * new的过程经过了这几步     * 1. let obj = {};新建一个对象，开辟空间     * 2. obj.__proto__ = Person.prototype;将对象的__proto__指向构造函数的prototype     * 3. Person.call(obj); 执行构造函数中的代码，注意。此时的this为obj     * 4. 最后返回obj</code></pre><p>在new的过程中，obj.__ <strong>proto__</strong> 指向构造函数的<strong>prototype</strong>，所以每个实例对象都存在一个__ __ <strong>proto</strong> __属性，而这个属性就是指向构造函数的<strong>prototype</strong>对象。</p><p><img src="/Users/mac/myblog/public/img/yuanxinglian/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" srcset="/img/loading.gif" alt></p><h3 id="3-原型链的构成"><a href="#3-原型链的构成" class="headerlink" title="3.原型链的构成"></a>3.原型链的构成</h3><blockquote><p>小总结：</p><p>1.每个函数都存在<strong>prototype</strong>和__ <strong>proto</strong> __ 。每个实例对象都存在__ <strong>proto</strong> __ 。</p><p>2.原型链就是实例对象的__ <strong>proto</strong> __ 指向构造函数的<strong>prototype</strong> ,构造函数的<strong>prtotype.__ <strong>proto</strong> __</strong>指向Object.<strong>prototype</strong>,最后的Object.prototype.__ <strong>proto</strong> __指向<strong>null</strong>，而只要是在这条链上的属性或方法，</p><p>实例对象都能访问</p></blockquote><p>在js中，只要是在原型链(prototype)上的属性，在哪个环节都可以任意的调用,例子↓</p><pre><code class="js">    //构造函数    function Person(name){    this.name = name;  }    //在构造函数原型对象上添加方法    Person.prototype.run = function(){    console.log(&quot;跑步&quot;);  }    //在Function上定义一个方法    Object.prototype.printfName = function(){    console.log(this.name);  }    //实例化对象    let per = new Person(&quot;GZH&quot;);    //此时per可以调用run()方法    per.run();//跑步    //也可以调用printfName方法,因为prototype是new Object()，也就是prototype是Object的实例对象，所以prototype中的__proto__指向Object的prototype,所以printfName也在per的原型链上,可以访问    per.printfName();//GZH</code></pre><h3 id="4-原型对象的指向是可以被改变的"><a href="#4-原型对象的指向是可以被改变的" class="headerlink" title="4. 原型对象的指向是可以被改变的"></a>4. 原型对象的指向是可以被改变的</h3><p>因为prototype也是一个对象，所以他也可以指向任何对象，这也是继承的重要基础。</p><pre><code class="js">    function Person(name) {      this.name = name;    }        Person.prototype.run = function(){      console.log(&quot;跑步&quot;);    }        function Student() {       }        Student.prototype.study = function(){      console.log(&quot;学习&quot;);    }        let stu1 = new Student();        //可以访问study，因为study在原型链上        stu1.study();//学习        //改变Student的指向，此时Student.prototype = {age,__proto__(指向Person的prototype)}        Student.prorotype = new Person();        let stu2 = new Student();        stu2.run();//可以访问，因为run()方法在原型链上        stu2.study();//报错，因为原型链上已经发生改变</code></pre><blockquote><p>持续更新中….</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GraphQL+nodejs+mongodb的使用</title>
    <link href="undefined2019/09/29/GraphQL-nodejs-mongodb%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>2019/09/29/GraphQL-nodejs-mongodb%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>今天闲着没事就看了一下GraphQL，其实刚开始我也不知道是干嘛用的</p></blockquote><h1 id="GraphQL-一种用于-API-的查询语言"><a href="#GraphQL-一种用于-API-的查询语言" class="headerlink" title="GraphQL,一种用于 API 的查询语言"></a><a href="https://graphql.cn/" target="_blank" rel="noopener">GraphQL</a>,一种用于 API 的查询语言</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。也是就后端返回的数据可能有些你用不到(数据冗余)，你可以按需取得你想要的数据。没错，就是这么强大。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><blockquote><p>GraphQL可以用于许多后端语言，我用得的是nodejs+express框架+mongoDB。</p></blockquote><ol><li><p>首先需要<code>npm install --save -D express express-graphql graphql</code> ，如果已经添加了express环境，则可以把express去掉。</p></li><li><p>在你对应的路由下，引入<code>const graphqlHTTP = require(&#39;express-graphql&#39;)</code> ，我的是在分发的graphql路由下。基本代码如下。</p><pre><code class="js">//graphql.js//已下是固定模式const express = require(&quot;express&quot;);const router = express.Router();const graphqlHTTP = require(&#39;express-graphql&#39;);const defalutschema = require(&#39;../schema/defualtschema&#39;);//schemarouter.use(&#39;/&#39;, graphqlHTTP({  schema: defalutschema,//  graphiql: true,}));module.exports = router;</code></pre></li><li><p>在根目录下新建一个schema目录，在这个目录新建defualtschema.js文件，也就是graphql.js的<code>const defalutschema = require(&#39;../schema/defualtschema&#39;);</code>添加以下的代码;</p><pre><code class="js">//defualtschema.jsconst {  GraphQLObjectType,  GraphQLString,  GraphQLInt,  GraphQLList,  GraphQLSchema,  GraphQLScalarType} = require(&#39;graphql&#39;);//引入mongoose的模型，const Food = require(&#39;../db/model/foodModel&#39;);const User = require(&#39;../db/model/userModel&#39;);const mongoose = require(&#39;mongoose&#39;);//创建schema一般分3步// 1.定义需要查询的Schema类型，类型需要在graphql模块取出。请看👆let foodSchema = new GraphQLObjectType({  //名字  name: &#39;food&#39;,  //字段，类型需要跟数据库表一致，我的数据库表具体内容在下面贴出。  fields: {    _id: {      type: GraphQLString    },    foodName: {      type: GraphQLString    },    foodPrice: {      type: GraphQLString    },    foodDec: {      type: GraphQLString    },    foodType: {      type: GraphQLString    },    foodTypeID: {      type: GraphQLInt    },  }});// 2.定义一个根，根里面定义调用foodSchema类型的方法let rootSchema = new GraphQLObjectType({  name: &#39;root&#39;,  fields: {    //这里的字段相当于一个方法,这里是获取foodList(食物的全部数据)    foodList: {      type: GraphQLList(foodSchema),//是一个数组，需要用GraphQLList包裹      async resolve(parent, args) {        let foodList = await Food.find();//mongoose封装的方法，用于查找数据库数据        return foodList;//将查询到的数据返回      }    },  }});//3.导出，默认格式module.exports = new GraphQLSchema({  query: rootSchema});</code></pre></li></ol><ol start="4"><li><p>打开浏览器，输入url，就会看到，以下界面，在左边输入<code>{}</code>，里面写得就是<code>rootSchema</code>中定义的字段<code>fields</code>，这里输入foodList，然后选择<strong>左上角的播放按钮</strong></p><p><img src="/Users/mac/myblog/public/img/GraphQL/GraphQL1.png" srcset="/img/loading.gif" alt="图1"></p><p>就会得到以下内容，右边就是返回的数据。你可以在左边选择你需要的字段比如</p><pre><code class="js">{    foodList{        foodName        foodPrice        FoodDec    }}//在右边就可得到你想要数据,是不是很神奇！！！</code></pre><p><img src="/Users/mac/myblog/public/img/GraphQL/GraphQL2.png" srcset="/img/loading.gif" alt="图2"></p></li></ol><ol start="5"><li><p>传入参数(这里用ID)来获取食物的信息，修改<code>rootSchema</code>中代码</p><pre><code class="js">let rootSchema = new GraphQLObjectType({  name: &#39;root&#39;,  fields: {    //这里的字段相当于一个方法,这里是获取foodList(食物的全部数据)    foodList: ...,    //按id查询食物信息    getFoodById: {      type: foodSchema,        //参数：这里传入ID      args: {        ID: {          type: GraphQLString        }      },      async resolve(parent, args) {        let id = mongoose.Types.ObjectId(args.ID);        let foodInfo = await Food.find({          _id: id        })        return foodInfo[0];//这里需要注意，因为返回的是一个数组，但是这里需要对象。      }    },  }});</code></pre></li></ol><pre><code>   回到浏览器，在`getFoodById(...)`方法中传入参数ID:&quot;…..&quot;,这里参数名字要和服务端的参数一致。   ![图三](/Users/mac/myblog/public/img/GraphQL/graphQL3.png)   这就是GraphQL的基本用法。## 总结GraphQL入门还算是比较简单的，不过要深入还有许多内容可以学，还没有学习前端如何调用接口，明天继续学，继续加油。</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>GraphQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端启示录</title>
    <link href="undefined2019/09/28/%E5%89%8D%E7%AB%AF%E5%90%AF%E7%A4%BA%E5%BD%95/"/>
    <url>2019/09/28/%E5%89%8D%E7%AB%AF%E5%90%AF%E7%A4%BA%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="暑假的锻炼"><a href="#暑假的锻炼" class="headerlink" title="暑假的锻炼"></a>暑假的锻炼</h1><p>上学期学期末，有个老师的团队前端缺人，正在招新，那时候刚学习完html+css+js，算是入门吧，发现自己对前端方向还是挺有兴趣了，后来就去应聘了，后来也顺利进入了团队。</p><p>刚进入那会，以为前端不就写写html+css嘛，没多难，后来看了一下师兄写的工程源码，一脸懵逼，原来html标签还能在js里这么用，后来知道了师兄用得技术栈是react，这是一种jsx语法。</p><p>师兄给我们列了一张暑假学习清单。如下图。</p><p><img src="/Users/mac/myblog/public/img/target1.png" srcset="/img/loading.gif" alt="学习任务"></p><p><img src="/Users/mac/myblog/public/img/target2.png" srcset="/img/loading.gif" alt="学习任务"></p><p>师兄还创建了一个coding仓库，在上面发布任务，让我们完成。前面的任务还好，不过这种理论的东西对于我来说真的是很难记全，都是看着会，用时废，也就草草百度搜索复制粘贴答案应付任务，总感觉这东西我已经掌握了，但是就是不知道该运用在哪里，然后过几天学其他东西就又把新东西给忘了，效率着实低下。我还是比较喜欢偏实战一点，所以我经常观看up主用html+css做出来的炫酷效果，然后按着他的思路再自己敲一遍，这样就对一些css样式有了更深的理解。学习完第一周后收获还是蛮大的，加深了以前对html+css+js的理解</p><p>第二周的东西就会比较难一点，全是高级js的内容，理解起来确实有点困难，在B站看了尚硅谷的js进阶课程，感觉不错，我记得那时候死磕原型链，睡前都在想万物皆对象，有了下面这张图就就很好理解了。</p><p><img src="/Users/mac/myblog/public/img/yuanxinglian.png" srcset="/img/loading.gif" alt="原型链"></p><p>对于闭包，其实他的概念并不复杂，函数内部中的函数访问父函数中声明的变量，不过到现在我都不知道该如何合理的运用，或许是我还没掌握吧23333</p><pre><code class="js">function init() {    var name = &quot;Mozilla&quot;; // name 是一个被 init 创建的局部变量    function displayName() { // displayName() 是内部函数,一个闭包        alert(name); // 使用了父函数中声明的变量    }    displayName();</code></pre><p>还学习了伟大的<strong>ajax</strong>和<strong>json</strong>，解开了动态网站神秘面纱，以前写得都是静态页面，不过学习了伟大的ajax后，对前后端有了一个更深层次的认识。还有jQuery，做特效也太强了，插件库用起来太爽了。不过师兄跟我说现在jQuery快要淘汰了，了解基本的就可以，不用学太深，我一脸懵逼。。。。</p><p>第三周，跟着B站千峰前端的nodejs课程，入门了让前端革命的nodejs，真没想到，js也能用来写服务端👍。nodejs牛逼！！！</p><p>学习了sass，预编译器确实比原生的方便太多了，嵌套写法让看起来结构更加清晰等等。还有es6，ts，不过都是入门而已，时间紧迫。</p><p>第四周，React，前端三大框架之一，记得最痛苦的就是刚开始学react安装配置的各种插件，webpack，babel等，配置这东西太难了，跟着视频做，配完隔天就忘记，着实难受。后来才知道了create-react-app这个脚手架，真的是福音，开源牛逼。记得学习了差不多两个多星期了react，跟着视频老师做了一个react全家桶+antd小项目，有点成就感，后来自己也添加了许多功能上去，一步一步的完善。</p><p>五周的学习终于熬过了，9106的学习时间，不过确实学习到了许多了东西，这些技术都是现在的热门技术，这半个暑假算是过得充实。我以为学完就可以跟着师兄一起做项目了，问了师兄接下来有什么安排，他叫我们先继续学。问他学什么，他也说巩固一下前面的知识吧，很敷衍。顿时很迷茫，索性就回宿舍学习了，后来又学习react-native，这个技术安装遇到的问题可太多，而且是网上很难找到那种，也是以一个小项目结束了，算是入门了吧。这是项目都这我们github仓库，有兴趣了可以去看看喔。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这篇文章，我把暑假所学习到的东西给大概回忆了一下，算是对暑假的一个总结，同时也是对知识点的回顾。</p><blockquote><p>勿喷文采排版，正学习中…..</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用hexo搭建个人博客</title>
    <link href="undefined2019/09/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <url>2019/09/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<ul><li><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029" target="_blank" rel="noopener">一篇很详细的hexo教程</a></p></li><li><p>一路下来安装的都挺顺利，基本没有坑，这次选择了一个<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">Fluid模板</a> ，基于 <code>Material-Design</code>风格，看起来就很舒服</p></li><li><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">官方主题库，各种风格都有</a></p></li><li><p>不过部署在github上访问真的是太慢啦🙃🙃🙃🙃</p></li></ul><blockquote><p>第一篇博客不知道写点啥，文采太差了😬，希望以后能有所提升。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/09/27/hello-world/"/>
    <url>2019/09/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>